/*
 * Swipe 2.0
 *
 * Brad Birdsall
 * Copyright 2013, MIT License
 *
*/

function Swipe(container, options) {

  "use strict";

  // utilities
  var noop = function() {}; // simple no operation function
  var offloadFn = function(fn) { setTimeout(fn || noop, 0) }; // offload a functions execution
  
  // check browser capabilities
  var browser = {
    addEventListener: !!window.addEventListener,
    touch: ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch,
    transitions: (function(temp) {
      var props = ['transformProperty', 'WebkitTransform', 'MozTransform', 'OTransform', 'msTransform'];
      for ( var i in props ) if (temp.style[ props[i] ] !== undefined) return true;
      return false;
    })(document.createElement('swipe'))
  };

  // quit if no root element
  if (!container) return;
  var element = container.children[0];
  var slides, slidePos, width;
  options = options || {};
  var index = parseInt(options.startSlide, 10) || 0;
  var speed = options.speed || 300;

  function setup() {

    // cache slides
    slides = element.children;

    // create an array to store current positions of each slide
    slidePos = new Array(slides.length);

    // determine width of each slide
    width = container.getBoundingClientRect().width || container.offsetWidth;

    element.style.width = (slides.length * width) + 'px';

    // stack elements
    var pos = slides.length;
    while(pos--) {

      var slide = slides[pos];

      slide.style.width = width + 'px';
      slide.setAttribute('data-index', pos);

      if (browser.transitions) {
        slide.style.left = (pos * -width) + 'px';
        move(pos, index > pos ? -width : (index < pos ? width : 0), 0);
      }

    }

    if (!browser.transitions) element.style.left = (index * -width) + 'px';

    container.style.visibility = 'visible';

  }

  function prev() {

    if (index) slide(index-1);
    else if (options.continuous) slide(slides.length-1);

  }

  function next() {

    if (index < slides.length - 1) slide(index+1);
    else if (options.continuous) slide(0);

  }

  function slide(to, slideSpeed) {

    // do nothing if already on requested slide
    if (index == to) return;
    
    if (browser.transitions) {

      var diff = Math.abs(index-to) - 1;
      var direction = Math.abs(index-to) / (index-to); // 1:right -1:left

      while (diff--) move((to > index ? to : index) - diff - 1, width * direction, 0);

      move(index, width * direction, slideSpeed || speed);
      move(to, 0, slideSpeed || speed);

    } else {

      animate(index * -width, to * -width, slideSpeed || speed);

    }

    index = to;

    offloadFn(options.callback && options.callback(index, slides[index]));

  }

  function move(index, dist, speed) {

    translate(index, dist, speed);
    slidePos[index] = dist;

  }

  function translate(index, dist, speed) {

    var slide = slides[index];
    var style = slide && slide.style;

    if (!style) return;

    style.webkitTransitionDuration = 
    style.MozTransitionDuration = 
    style.msTransitionDuration = 
    style.OTransitionDuration = 
    style.transitionDuration = speed + 'ms';

    style.webkitTransform = 'translate(' + dist + 'px,0)' + 'translateZ(0)';
    style.msTransform = 
    style.MozTransform = 
    style.OTransform = 'translateX(' + dist + 'px)';

  }

  function animate(from, to, speed) {

    // if not an animation, just reposition
    if (!speed) {
      
      element.style.left = to + 'px';
      return;

    }
    
    var start = +new Date;
    
    var timer = setInterval(function() {

      var timeElap = +new Date - start;
      
      if (timeElap > speed) {

        element.style.left = to + 'px';

        if (delay) begin();

        options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);

        clearInterval(timer);
        return;

      }

      element.style.left = (( (to - from) * (Math.floor((timeElap / speed) * 100) / 100) ) + from) + 'px';

    }, 4);

  }

  // setup auto slideshow
  var delay = options.auto || 0;
  var interval;

  function begin() {

    interval = setTimeout(next, delay);

  }

  function stop() {

    delay = 0;
    clearTimeout(interval);

  }


  // setup initial vars
  var start = {};
  var delta = {};
  var isScrolling;      

  // setup event capturing
  var events = {

    handleEvent: function(event) {

      switch (event.type) {
        case 'touchstart': this.start(event); break;
        case 'touchmove': this.move(event); break;
        case 'touchend': offloadFn(this.end(event)); break;
        case 'webkitTransitionEnd':
        case 'msTransitionEnd':
        case 'oTransitionEnd':
        case 'otransitionend':
        case 'transitionend': offloadFn(this.transitionEnd(event)); break;
        case 'resize': offloadFn(setup.call()); break;
      }

      if (options.stopPropagation) event.stopPropagation();

    },
    start: function(event) {

      var touches = event.touches[0];

      // measure start values
      start = {

        // get initial touch coords
        x: touches.pageX,
        y: touches.pageY,

        // store time to determine touch duration
        time: +new Date

      };
      
      // used for testing first move event
      isScrolling = undefined;

      // reset delta and end measurements
      delta = {};

      // attach touchmove and touchend listeners
      element.addEventListener('touchmove', this, false);
      element.addEventListener('touchend', this, false);

    },
    move: function(event) {

      // ensure swiping with one touch and not pinching
      if ( event.touches.length > 1 || event.scale && event.scale !== 1) return

      if (options.disableScroll) event.preventDefault();

      var touches = event.touches[0];

      // measure change in x and y
      delta = {
        x: touches.pageX - start.x,
        y: touches.pageY - start.y
      }

      // determine if scrolling test has run - one time test
      if ( typeof isScrolling == 'undefined') {
        isScrolling = !!( isScrolling || Math.abs(delta.x) < Math.abs(delta.y) );
      }

      // if user is not trying to scroll vertically
      if (!isScrolling) {

        // prevent native scrolling 
        event.preventDefault();

        // stop slideshow
        stop();

        // increase resistance if first or last slide
        delta.x = 
          delta.x / 
            ( (!index && delta.x > 0               // if first slide and sliding left
              || index == slides.length - 1        // or if last slide and sliding right
              && delta.x < 0                       // and if sliding at all
            ) ?                      
            ( Math.abs(delta.x) / width + 1 )      // determine resistance level
            : 1 );                                 // no resistance if false
        
        // translate 1:1
        translate(index-1, delta.x + slidePos[index-1], 0);
        translate(index, delta.x + slidePos[index], 0);
        translate(index+1, delta.x + slidePos[index+1], 0);

      }

    },
    end: function(event) {

      // measure duration
      var duration = +new Date - start.time;

      // determine if slide attempt triggers next/prev slide
      var isValidSlide = 
            Number(duration) < 250               // if slide duration is less than 250ms
            && Math.abs(delta.x) > 20            // and if slide amt is greater than 20px
            || Math.abs(delta.x) > width/2;      // or if slide amt is greater than half the width

      // determine if slide attempt is past start and end
      var isPastBounds = 
            !index && delta.x > 0                            // if first slide and slide amt is greater than 0
            || index == slides.length - 1 && delta.x < 0;    // or if last slide and slide amt is less than 0
      
      // determine direction of swipe (true:right, false:left)
      var direction = delta.x < 0;

      // if not scrolling vertically
      if (!isScrolling) {

        if (isValidSlide && !isPastBounds) {

          if (direction) {

            move(index-1, -width, 0);
            move(index, slidePos[index]-width, speed);
            move(index+1, slidePos[index+1]-width, speed);
            index += 1;

          } else {

            move(index+1, width, 0);
            move(index, slidePos[index]+width, speed);
            move(index-1, slidePos[index-1]+width, speed);
            index += -1;

          }

          options.callback && options.callback(index, slides[index]);

        } else {

          move(index-1, -width, speed);
          move(index, 0, speed);
          move(index+1, width, speed);

        }

      }

      // kill touchmove and touchend event listeners until touchstart called again
      element.removeEventListener('touchmove', events, false)
      element.removeEventListener('touchend', events, false)

    },
    transitionEnd: function(event) {

      if (parseInt(event.target.getAttribute('data-index'), 10) == index) {
        
        if (delay) begin();

        options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);

      }

    }

  }

  // trigger setup
  setup();

  // start auto slideshow if applicable
  if (delay) begin();


  // add event listeners
  if (browser.addEventListener) {
    
    // set touchstart event on element    
    if (browser.touch) element.addEventListener('touchstart', events, false);

    if (browser.transitions) {
      element.addEventListener('webkitTransitionEnd', events, false);
      element.addEventListener('msTransitionEnd', events, false);
      element.addEventListener('oTransitionEnd', events, false);
      element.addEventListener('otransitionend', events, false);
      element.addEventListener('transitionend', events, false);
    }

    // set resize event on window
    window.addEventListener('resize', events, false);

  } else {

    window.onresize = function () { setup() }; // to play nice with old IE

  }

  // expose the Swipe API
  return {
    setup: function() {

      setup();

    },
    slide: function(to, speed) {

      slide(to, speed);

    },
    prev: function() {

      // cancel slideshow
      stop();

      prev();

    },
    next: function() {

      stop();

      next();

    },
    getPos: function() {

      // return current index position
      return index;

    },
    kill: function() {

      // cancel slideshow
      stop();

      // reset element
      element.style.width = 'auto';
      element.style.left = 0;

      // reset slides
      var pos = slides.length;
      while(pos--) {

        var slide = slides[pos];
        slide.style.width = '100%';
        slide.style.left = 0;

        if (browser.transitions) translate(pos, 0, 0);

      }

      // removed event listeners
      if (browser.addEventListener) {

        // remove current event listeners
        element.removeEventListener('touchstart', events, false);
        element.removeEventListener('webkitTransitionEnd', events, false);
        element.removeEventListener('msTransitionEnd', events, false);
        element.removeEventListener('oTransitionEnd', events, false);
        element.removeEventListener('otransitionend', events, false);
        element.removeEventListener('transitionend', events, false);
        window.removeEventListener('resize', events, false);

      }
      else {

        window.onresize = null;

      }

    }
  }

}


if ( window.jQuery || window.Zepto ) {
  (function($) {
    $.fn.Swipe = function(params) {
      return this.each(function() {
        $(this).data('Swipe', new Swipe($(this)[0], params));
      });
    }
  })( window.jQuery || window.Zepto )
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJzd2lwZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogU3dpcGUgMi4wXG4gKlxuICogQnJhZCBCaXJkc2FsbFxuICogQ29weXJpZ2h0IDIwMTMsIE1JVCBMaWNlbnNlXG4gKlxuKi9cblxuZnVuY3Rpb24gU3dpcGUoY29udGFpbmVyLCBvcHRpb25zKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLy8gdXRpbGl0aWVzXG4gIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTsgLy8gc2ltcGxlIG5vIG9wZXJhdGlvbiBmdW5jdGlvblxuICB2YXIgb2ZmbG9hZEZuID0gZnVuY3Rpb24oZm4pIHsgc2V0VGltZW91dChmbiB8fCBub29wLCAwKSB9OyAvLyBvZmZsb2FkIGEgZnVuY3Rpb25zIGV4ZWN1dGlvblxuICBcbiAgLy8gY2hlY2sgYnJvd3NlciBjYXBhYmlsaXRpZXNcbiAgdmFyIGJyb3dzZXIgPSB7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogISF3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcixcbiAgICB0b3VjaDogKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudFRvdWNoLFxuICAgIHRyYW5zaXRpb25zOiAoZnVuY3Rpb24odGVtcCkge1xuICAgICAgdmFyIHByb3BzID0gWyd0cmFuc2Zvcm1Qcm9wZXJ0eScsICdXZWJraXRUcmFuc2Zvcm0nLCAnTW96VHJhbnNmb3JtJywgJ09UcmFuc2Zvcm0nLCAnbXNUcmFuc2Zvcm0nXTtcbiAgICAgIGZvciAoIHZhciBpIGluIHByb3BzICkgaWYgKHRlbXAuc3R5bGVbIHByb3BzW2ldIF0gIT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSkoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3dpcGUnKSlcbiAgfTtcblxuICAvLyBxdWl0IGlmIG5vIHJvb3QgZWxlbWVudFxuICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuO1xuICB2YXIgZWxlbWVudCA9IGNvbnRhaW5lci5jaGlsZHJlblswXTtcbiAgdmFyIHNsaWRlcywgc2xpZGVQb3MsIHdpZHRoO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGluZGV4ID0gcGFyc2VJbnQob3B0aW9ucy5zdGFydFNsaWRlLCAxMCkgfHwgMDtcbiAgdmFyIHNwZWVkID0gb3B0aW9ucy5zcGVlZCB8fCAzMDA7XG5cbiAgZnVuY3Rpb24gc2V0dXAoKSB7XG5cbiAgICAvLyBjYWNoZSBzbGlkZXNcbiAgICBzbGlkZXMgPSBlbGVtZW50LmNoaWxkcmVuO1xuXG4gICAgLy8gY3JlYXRlIGFuIGFycmF5IHRvIHN0b3JlIGN1cnJlbnQgcG9zaXRpb25zIG9mIGVhY2ggc2xpZGVcbiAgICBzbGlkZVBvcyA9IG5ldyBBcnJheShzbGlkZXMubGVuZ3RoKTtcblxuICAgIC8vIGRldGVybWluZSB3aWR0aCBvZiBlYWNoIHNsaWRlXG4gICAgd2lkdGggPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggfHwgY29udGFpbmVyLm9mZnNldFdpZHRoO1xuXG4gICAgZWxlbWVudC5zdHlsZS53aWR0aCA9IChzbGlkZXMubGVuZ3RoICogd2lkdGgpICsgJ3B4JztcblxuICAgIC8vIHN0YWNrIGVsZW1lbnRzXG4gICAgdmFyIHBvcyA9IHNsaWRlcy5sZW5ndGg7XG4gICAgd2hpbGUocG9zLS0pIHtcblxuICAgICAgdmFyIHNsaWRlID0gc2xpZGVzW3Bvc107XG5cbiAgICAgIHNsaWRlLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgc2xpZGUuc2V0QXR0cmlidXRlKCdkYXRhLWluZGV4JywgcG9zKTtcblxuICAgICAgaWYgKGJyb3dzZXIudHJhbnNpdGlvbnMpIHtcbiAgICAgICAgc2xpZGUuc3R5bGUubGVmdCA9IChwb3MgKiAtd2lkdGgpICsgJ3B4JztcbiAgICAgICAgbW92ZShwb3MsIGluZGV4ID4gcG9zID8gLXdpZHRoIDogKGluZGV4IDwgcG9zID8gd2lkdGggOiAwKSwgMCk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAoIWJyb3dzZXIudHJhbnNpdGlvbnMpIGVsZW1lbnQuc3R5bGUubGVmdCA9IChpbmRleCAqIC13aWR0aCkgKyAncHgnO1xuXG4gICAgY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXYoKSB7XG5cbiAgICBpZiAoaW5kZXgpIHNsaWRlKGluZGV4LTEpO1xuICAgIGVsc2UgaWYgKG9wdGlvbnMuY29udGludW91cykgc2xpZGUoc2xpZGVzLmxlbmd0aC0xKTtcblxuICB9XG5cbiAgZnVuY3Rpb24gbmV4dCgpIHtcblxuICAgIGlmIChpbmRleCA8IHNsaWRlcy5sZW5ndGggLSAxKSBzbGlkZShpbmRleCsxKTtcbiAgICBlbHNlIGlmIChvcHRpb25zLmNvbnRpbnVvdXMpIHNsaWRlKDApO1xuXG4gIH1cblxuICBmdW5jdGlvbiBzbGlkZSh0bywgc2xpZGVTcGVlZCkge1xuXG4gICAgLy8gZG8gbm90aGluZyBpZiBhbHJlYWR5IG9uIHJlcXVlc3RlZCBzbGlkZVxuICAgIGlmIChpbmRleCA9PSB0bykgcmV0dXJuO1xuICAgIFxuICAgIGlmIChicm93c2VyLnRyYW5zaXRpb25zKSB7XG5cbiAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMoaW5kZXgtdG8pIC0gMTtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBNYXRoLmFicyhpbmRleC10bykgLyAoaW5kZXgtdG8pOyAvLyAxOnJpZ2h0IC0xOmxlZnRcblxuICAgICAgd2hpbGUgKGRpZmYtLSkgbW92ZSgodG8gPiBpbmRleCA/IHRvIDogaW5kZXgpIC0gZGlmZiAtIDEsIHdpZHRoICogZGlyZWN0aW9uLCAwKTtcblxuICAgICAgbW92ZShpbmRleCwgd2lkdGggKiBkaXJlY3Rpb24sIHNsaWRlU3BlZWQgfHwgc3BlZWQpO1xuICAgICAgbW92ZSh0bywgMCwgc2xpZGVTcGVlZCB8fCBzcGVlZCk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBhbmltYXRlKGluZGV4ICogLXdpZHRoLCB0byAqIC13aWR0aCwgc2xpZGVTcGVlZCB8fCBzcGVlZCk7XG5cbiAgICB9XG5cbiAgICBpbmRleCA9IHRvO1xuXG4gICAgb2ZmbG9hZEZuKG9wdGlvbnMuY2FsbGJhY2sgJiYgb3B0aW9ucy5jYWxsYmFjayhpbmRleCwgc2xpZGVzW2luZGV4XSkpO1xuXG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlKGluZGV4LCBkaXN0LCBzcGVlZCkge1xuXG4gICAgdHJhbnNsYXRlKGluZGV4LCBkaXN0LCBzcGVlZCk7XG4gICAgc2xpZGVQb3NbaW5kZXhdID0gZGlzdDtcblxuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNsYXRlKGluZGV4LCBkaXN0LCBzcGVlZCkge1xuXG4gICAgdmFyIHNsaWRlID0gc2xpZGVzW2luZGV4XTtcbiAgICB2YXIgc3R5bGUgPSBzbGlkZSAmJiBzbGlkZS5zdHlsZTtcblxuICAgIGlmICghc3R5bGUpIHJldHVybjtcblxuICAgIHN0eWxlLndlYmtpdFRyYW5zaXRpb25EdXJhdGlvbiA9IFxuICAgIHN0eWxlLk1velRyYW5zaXRpb25EdXJhdGlvbiA9IFxuICAgIHN0eWxlLm1zVHJhbnNpdGlvbkR1cmF0aW9uID0gXG4gICAgc3R5bGUuT1RyYW5zaXRpb25EdXJhdGlvbiA9IFxuICAgIHN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IHNwZWVkICsgJ21zJztcblxuICAgIHN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIGRpc3QgKyAncHgsMCknICsgJ3RyYW5zbGF0ZVooMCknO1xuICAgIHN0eWxlLm1zVHJhbnNmb3JtID0gXG4gICAgc3R5bGUuTW96VHJhbnNmb3JtID0gXG4gICAgc3R5bGUuT1RyYW5zZm9ybSA9ICd0cmFuc2xhdGVYKCcgKyBkaXN0ICsgJ3B4KSc7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGFuaW1hdGUoZnJvbSwgdG8sIHNwZWVkKSB7XG5cbiAgICAvLyBpZiBub3QgYW4gYW5pbWF0aW9uLCBqdXN0IHJlcG9zaXRpb25cbiAgICBpZiAoIXNwZWVkKSB7XG4gICAgICBcbiAgICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9IHRvICsgJ3B4JztcbiAgICAgIHJldHVybjtcblxuICAgIH1cbiAgICBcbiAgICB2YXIgc3RhcnQgPSArbmV3IERhdGU7XG4gICAgXG4gICAgdmFyIHRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciB0aW1lRWxhcCA9ICtuZXcgRGF0ZSAtIHN0YXJ0O1xuICAgICAgXG4gICAgICBpZiAodGltZUVsYXAgPiBzcGVlZCkge1xuXG4gICAgICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9IHRvICsgJ3B4JztcblxuICAgICAgICBpZiAoZGVsYXkpIGJlZ2luKCk7XG5cbiAgICAgICAgb3B0aW9ucy50cmFuc2l0aW9uRW5kICYmIG9wdGlvbnMudHJhbnNpdGlvbkVuZC5jYWxsKGV2ZW50LCBpbmRleCwgc2xpZGVzW2luZGV4XSk7XG5cbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgfVxuXG4gICAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSAoKCAodG8gLSBmcm9tKSAqIChNYXRoLmZsb29yKCh0aW1lRWxhcCAvIHNwZWVkKSAqIDEwMCkgLyAxMDApICkgKyBmcm9tKSArICdweCc7XG5cbiAgICB9LCA0KTtcblxuICB9XG5cbiAgLy8gc2V0dXAgYXV0byBzbGlkZXNob3dcbiAgdmFyIGRlbGF5ID0gb3B0aW9ucy5hdXRvIHx8IDA7XG4gIHZhciBpbnRlcnZhbDtcblxuICBmdW5jdGlvbiBiZWdpbigpIHtcblxuICAgIGludGVydmFsID0gc2V0VGltZW91dChuZXh0LCBkZWxheSk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG5cbiAgICBkZWxheSA9IDA7XG4gICAgY2xlYXJUaW1lb3V0KGludGVydmFsKTtcblxuICB9XG5cblxuICAvLyBzZXR1cCBpbml0aWFsIHZhcnNcbiAgdmFyIHN0YXJ0ID0ge307XG4gIHZhciBkZWx0YSA9IHt9O1xuICB2YXIgaXNTY3JvbGxpbmc7ICAgICAgXG5cbiAgLy8gc2V0dXAgZXZlbnQgY2FwdHVyaW5nXG4gIHZhciBldmVudHMgPSB7XG5cbiAgICBoYW5kbGVFdmVudDogZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3RvdWNoc3RhcnQnOiB0aGlzLnN0YXJ0KGV2ZW50KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvdWNobW92ZSc6IHRoaXMubW92ZShldmVudCk7IGJyZWFrO1xuICAgICAgICBjYXNlICd0b3VjaGVuZCc6IG9mZmxvYWRGbih0aGlzLmVuZChldmVudCkpOyBicmVhaztcbiAgICAgICAgY2FzZSAnd2Via2l0VHJhbnNpdGlvbkVuZCc6XG4gICAgICAgIGNhc2UgJ21zVHJhbnNpdGlvbkVuZCc6XG4gICAgICAgIGNhc2UgJ29UcmFuc2l0aW9uRW5kJzpcbiAgICAgICAgY2FzZSAnb3RyYW5zaXRpb25lbmQnOlxuICAgICAgICBjYXNlICd0cmFuc2l0aW9uZW5kJzogb2ZmbG9hZEZuKHRoaXMudHJhbnNpdGlvbkVuZChldmVudCkpOyBicmVhaztcbiAgICAgICAgY2FzZSAncmVzaXplJzogb2ZmbG9hZEZuKHNldHVwLmNhbGwoKSk7IGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5zdG9wUHJvcGFnYXRpb24pIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgfSxcbiAgICBzdGFydDogZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgdmFyIHRvdWNoZXMgPSBldmVudC50b3VjaGVzWzBdO1xuXG4gICAgICAvLyBtZWFzdXJlIHN0YXJ0IHZhbHVlc1xuICAgICAgc3RhcnQgPSB7XG5cbiAgICAgICAgLy8gZ2V0IGluaXRpYWwgdG91Y2ggY29vcmRzXG4gICAgICAgIHg6IHRvdWNoZXMucGFnZVgsXG4gICAgICAgIHk6IHRvdWNoZXMucGFnZVksXG5cbiAgICAgICAgLy8gc3RvcmUgdGltZSB0byBkZXRlcm1pbmUgdG91Y2ggZHVyYXRpb25cbiAgICAgICAgdGltZTogK25ldyBEYXRlXG5cbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIHVzZWQgZm9yIHRlc3RpbmcgZmlyc3QgbW92ZSBldmVudFxuICAgICAgaXNTY3JvbGxpbmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIC8vIHJlc2V0IGRlbHRhIGFuZCBlbmQgbWVhc3VyZW1lbnRzXG4gICAgICBkZWx0YSA9IHt9O1xuXG4gICAgICAvLyBhdHRhY2ggdG91Y2htb3ZlIGFuZCB0b3VjaGVuZCBsaXN0ZW5lcnNcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcywgZmFsc2UpO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMsIGZhbHNlKTtcblxuICAgIH0sXG4gICAgbW92ZTogZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgLy8gZW5zdXJlIHN3aXBpbmcgd2l0aCBvbmUgdG91Y2ggYW5kIG5vdCBwaW5jaGluZ1xuICAgICAgaWYgKCBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEgfHwgZXZlbnQuc2NhbGUgJiYgZXZlbnQuc2NhbGUgIT09IDEpIHJldHVyblxuXG4gICAgICBpZiAob3B0aW9ucy5kaXNhYmxlU2Nyb2xsKSBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXNbMF07XG5cbiAgICAgIC8vIG1lYXN1cmUgY2hhbmdlIGluIHggYW5kIHlcbiAgICAgIGRlbHRhID0ge1xuICAgICAgICB4OiB0b3VjaGVzLnBhZ2VYIC0gc3RhcnQueCxcbiAgICAgICAgeTogdG91Y2hlcy5wYWdlWSAtIHN0YXJ0LnlcbiAgICAgIH1cblxuICAgICAgLy8gZGV0ZXJtaW5lIGlmIHNjcm9sbGluZyB0ZXN0IGhhcyBydW4gLSBvbmUgdGltZSB0ZXN0XG4gICAgICBpZiAoIHR5cGVvZiBpc1Njcm9sbGluZyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpc1Njcm9sbGluZyA9ICEhKCBpc1Njcm9sbGluZyB8fCBNYXRoLmFicyhkZWx0YS54KSA8IE1hdGguYWJzKGRlbHRhLnkpICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHVzZXIgaXMgbm90IHRyeWluZyB0byBzY3JvbGwgdmVydGljYWxseVxuICAgICAgaWYgKCFpc1Njcm9sbGluZykge1xuXG4gICAgICAgIC8vIHByZXZlbnQgbmF0aXZlIHNjcm9sbGluZyBcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBzdG9wIHNsaWRlc2hvd1xuICAgICAgICBzdG9wKCk7XG5cbiAgICAgICAgLy8gaW5jcmVhc2UgcmVzaXN0YW5jZSBpZiBmaXJzdCBvciBsYXN0IHNsaWRlXG4gICAgICAgIGRlbHRhLnggPSBcbiAgICAgICAgICBkZWx0YS54IC8gXG4gICAgICAgICAgICAoICghaW5kZXggJiYgZGVsdGEueCA+IDAgICAgICAgICAgICAgICAvLyBpZiBmaXJzdCBzbGlkZSBhbmQgc2xpZGluZyBsZWZ0XG4gICAgICAgICAgICAgIHx8IGluZGV4ID09IHNsaWRlcy5sZW5ndGggLSAxICAgICAgICAvLyBvciBpZiBsYXN0IHNsaWRlIGFuZCBzbGlkaW5nIHJpZ2h0XG4gICAgICAgICAgICAgICYmIGRlbHRhLnggPCAwICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgaWYgc2xpZGluZyBhdCBhbGxcbiAgICAgICAgICAgICkgPyAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICggTWF0aC5hYnMoZGVsdGEueCkgLyB3aWR0aCArIDEgKSAgICAgIC8vIGRldGVybWluZSByZXNpc3RhbmNlIGxldmVsXG4gICAgICAgICAgICA6IDEgKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBubyByZXNpc3RhbmNlIGlmIGZhbHNlXG4gICAgICAgIFxuICAgICAgICAvLyB0cmFuc2xhdGUgMToxXG4gICAgICAgIHRyYW5zbGF0ZShpbmRleC0xLCBkZWx0YS54ICsgc2xpZGVQb3NbaW5kZXgtMV0sIDApO1xuICAgICAgICB0cmFuc2xhdGUoaW5kZXgsIGRlbHRhLnggKyBzbGlkZVBvc1tpbmRleF0sIDApO1xuICAgICAgICB0cmFuc2xhdGUoaW5kZXgrMSwgZGVsdGEueCArIHNsaWRlUG9zW2luZGV4KzFdLCAwKTtcblxuICAgICAgfVxuXG4gICAgfSxcbiAgICBlbmQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgIC8vIG1lYXN1cmUgZHVyYXRpb25cbiAgICAgIHZhciBkdXJhdGlvbiA9ICtuZXcgRGF0ZSAtIHN0YXJ0LnRpbWU7XG5cbiAgICAgIC8vIGRldGVybWluZSBpZiBzbGlkZSBhdHRlbXB0IHRyaWdnZXJzIG5leHQvcHJldiBzbGlkZVxuICAgICAgdmFyIGlzVmFsaWRTbGlkZSA9IFxuICAgICAgICAgICAgTnVtYmVyKGR1cmF0aW9uKSA8IDI1MCAgICAgICAgICAgICAgIC8vIGlmIHNsaWRlIGR1cmF0aW9uIGlzIGxlc3MgdGhhbiAyNTBtc1xuICAgICAgICAgICAgJiYgTWF0aC5hYnMoZGVsdGEueCkgPiAyMCAgICAgICAgICAgIC8vIGFuZCBpZiBzbGlkZSBhbXQgaXMgZ3JlYXRlciB0aGFuIDIwcHhcbiAgICAgICAgICAgIHx8IE1hdGguYWJzKGRlbHRhLngpID4gd2lkdGgvMjsgICAgICAvLyBvciBpZiBzbGlkZSBhbXQgaXMgZ3JlYXRlciB0aGFuIGhhbGYgdGhlIHdpZHRoXG5cbiAgICAgIC8vIGRldGVybWluZSBpZiBzbGlkZSBhdHRlbXB0IGlzIHBhc3Qgc3RhcnQgYW5kIGVuZFxuICAgICAgdmFyIGlzUGFzdEJvdW5kcyA9IFxuICAgICAgICAgICAgIWluZGV4ICYmIGRlbHRhLnggPiAwICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGZpcnN0IHNsaWRlIGFuZCBzbGlkZSBhbXQgaXMgZ3JlYXRlciB0aGFuIDBcbiAgICAgICAgICAgIHx8IGluZGV4ID09IHNsaWRlcy5sZW5ndGggLSAxICYmIGRlbHRhLnggPCAwOyAgICAvLyBvciBpZiBsYXN0IHNsaWRlIGFuZCBzbGlkZSBhbXQgaXMgbGVzcyB0aGFuIDBcbiAgICAgIFxuICAgICAgLy8gZGV0ZXJtaW5lIGRpcmVjdGlvbiBvZiBzd2lwZSAodHJ1ZTpyaWdodCwgZmFsc2U6bGVmdClcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBkZWx0YS54IDwgMDtcblxuICAgICAgLy8gaWYgbm90IHNjcm9sbGluZyB2ZXJ0aWNhbGx5XG4gICAgICBpZiAoIWlzU2Nyb2xsaW5nKSB7XG5cbiAgICAgICAgaWYgKGlzVmFsaWRTbGlkZSAmJiAhaXNQYXN0Qm91bmRzKSB7XG5cbiAgICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG5cbiAgICAgICAgICAgIG1vdmUoaW5kZXgtMSwgLXdpZHRoLCAwKTtcbiAgICAgICAgICAgIG1vdmUoaW5kZXgsIHNsaWRlUG9zW2luZGV4XS13aWR0aCwgc3BlZWQpO1xuICAgICAgICAgICAgbW92ZShpbmRleCsxLCBzbGlkZVBvc1tpbmRleCsxXS13aWR0aCwgc3BlZWQpO1xuICAgICAgICAgICAgaW5kZXggKz0gMTtcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIG1vdmUoaW5kZXgrMSwgd2lkdGgsIDApO1xuICAgICAgICAgICAgbW92ZShpbmRleCwgc2xpZGVQb3NbaW5kZXhdK3dpZHRoLCBzcGVlZCk7XG4gICAgICAgICAgICBtb3ZlKGluZGV4LTEsIHNsaWRlUG9zW2luZGV4LTFdK3dpZHRoLCBzcGVlZCk7XG4gICAgICAgICAgICBpbmRleCArPSAtMTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2sgJiYgb3B0aW9ucy5jYWxsYmFjayhpbmRleCwgc2xpZGVzW2luZGV4XSk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIG1vdmUoaW5kZXgtMSwgLXdpZHRoLCBzcGVlZCk7XG4gICAgICAgICAgbW92ZShpbmRleCwgMCwgc3BlZWQpO1xuICAgICAgICAgIG1vdmUoaW5kZXgrMSwgd2lkdGgsIHNwZWVkKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgLy8ga2lsbCB0b3VjaG1vdmUgYW5kIHRvdWNoZW5kIGV2ZW50IGxpc3RlbmVycyB1bnRpbCB0b3VjaHN0YXJ0IGNhbGxlZCBhZ2FpblxuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBldmVudHMsIGZhbHNlKVxuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGV2ZW50cywgZmFsc2UpXG5cbiAgICB9LFxuICAgIHRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgIGlmIChwYXJzZUludChldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWluZGV4JyksIDEwKSA9PSBpbmRleCkge1xuICAgICAgICBcbiAgICAgICAgaWYgKGRlbGF5KSBiZWdpbigpO1xuXG4gICAgICAgIG9wdGlvbnMudHJhbnNpdGlvbkVuZCAmJiBvcHRpb25zLnRyYW5zaXRpb25FbmQuY2FsbChldmVudCwgaW5kZXgsIHNsaWRlc1tpbmRleF0pO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIC8vIHRyaWdnZXIgc2V0dXBcbiAgc2V0dXAoKTtcblxuICAvLyBzdGFydCBhdXRvIHNsaWRlc2hvdyBpZiBhcHBsaWNhYmxlXG4gIGlmIChkZWxheSkgYmVnaW4oKTtcblxuXG4gIC8vIGFkZCBldmVudCBsaXN0ZW5lcnNcbiAgaWYgKGJyb3dzZXIuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIFxuICAgIC8vIHNldCB0b3VjaHN0YXJ0IGV2ZW50IG9uIGVsZW1lbnQgICAgXG4gICAgaWYgKGJyb3dzZXIudG91Y2gpIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGV2ZW50cywgZmFsc2UpO1xuXG4gICAgaWYgKGJyb3dzZXIudHJhbnNpdGlvbnMpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0VHJhbnNpdGlvbkVuZCcsIGV2ZW50cywgZmFsc2UpO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtc1RyYW5zaXRpb25FbmQnLCBldmVudHMsIGZhbHNlKTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignb1RyYW5zaXRpb25FbmQnLCBldmVudHMsIGZhbHNlKTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignb3RyYW5zaXRpb25lbmQnLCBldmVudHMsIGZhbHNlKTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGV2ZW50cywgZmFsc2UpO1xuICAgIH1cblxuICAgIC8vIHNldCByZXNpemUgZXZlbnQgb24gd2luZG93XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGV2ZW50cywgZmFsc2UpO1xuXG4gIH0gZWxzZSB7XG5cbiAgICB3aW5kb3cub25yZXNpemUgPSBmdW5jdGlvbiAoKSB7IHNldHVwKCkgfTsgLy8gdG8gcGxheSBuaWNlIHdpdGggb2xkIElFXG5cbiAgfVxuXG4gIC8vIGV4cG9zZSB0aGUgU3dpcGUgQVBJXG4gIHJldHVybiB7XG4gICAgc2V0dXA6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBzZXR1cCgpO1xuXG4gICAgfSxcbiAgICBzbGlkZTogZnVuY3Rpb24odG8sIHNwZWVkKSB7XG5cbiAgICAgIHNsaWRlKHRvLCBzcGVlZCk7XG5cbiAgICB9LFxuICAgIHByZXY6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAvLyBjYW5jZWwgc2xpZGVzaG93XG4gICAgICBzdG9wKCk7XG5cbiAgICAgIHByZXYoKTtcblxuICAgIH0sXG4gICAgbmV4dDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHN0b3AoKTtcblxuICAgICAgbmV4dCgpO1xuXG4gICAgfSxcbiAgICBnZXRQb3M6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAvLyByZXR1cm4gY3VycmVudCBpbmRleCBwb3NpdGlvblxuICAgICAgcmV0dXJuIGluZGV4O1xuXG4gICAgfSxcbiAgICBraWxsOiBmdW5jdGlvbigpIHtcblxuICAgICAgLy8gY2FuY2VsIHNsaWRlc2hvd1xuICAgICAgc3RvcCgpO1xuXG4gICAgICAvLyByZXNldCBlbGVtZW50XG4gICAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gJ2F1dG8nO1xuICAgICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gMDtcblxuICAgICAgLy8gcmVzZXQgc2xpZGVzXG4gICAgICB2YXIgcG9zID0gc2xpZGVzLmxlbmd0aDtcbiAgICAgIHdoaWxlKHBvcy0tKSB7XG5cbiAgICAgICAgdmFyIHNsaWRlID0gc2xpZGVzW3Bvc107XG4gICAgICAgIHNsaWRlLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICBzbGlkZS5zdHlsZS5sZWZ0ID0gMDtcblxuICAgICAgICBpZiAoYnJvd3Nlci50cmFuc2l0aW9ucykgdHJhbnNsYXRlKHBvcywgMCwgMCk7XG5cbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlZCBldmVudCBsaXN0ZW5lcnNcbiAgICAgIGlmIChicm93c2VyLmFkZEV2ZW50TGlzdGVuZXIpIHtcblxuICAgICAgICAvLyByZW1vdmUgY3VycmVudCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZXZlbnRzLCBmYWxzZSk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0VHJhbnNpdGlvbkVuZCcsIGV2ZW50cywgZmFsc2UpO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21zVHJhbnNpdGlvbkVuZCcsIGV2ZW50cywgZmFsc2UpO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29UcmFuc2l0aW9uRW5kJywgZXZlbnRzLCBmYWxzZSk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3RyYW5zaXRpb25lbmQnLCBldmVudHMsIGZhbHNlKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZXZlbnRzLCBmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBldmVudHMsIGZhbHNlKTtcblxuICAgICAgfVxuICAgICAgZWxzZSB7XG5cbiAgICAgICAgd2luZG93Lm9ucmVzaXplID0gbnVsbDtcblxuICAgICAgfVxuXG4gICAgfVxuICB9XG5cbn1cblxuXG5pZiAoIHdpbmRvdy5qUXVlcnkgfHwgd2luZG93LlplcHRvICkge1xuICAoZnVuY3Rpb24oJCkge1xuICAgICQuZm4uU3dpcGUgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICQodGhpcykuZGF0YSgnU3dpcGUnLCBuZXcgU3dpcGUoJCh0aGlzKVswXSwgcGFyYW1zKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pKCB3aW5kb3cualF1ZXJ5IHx8IHdpbmRvdy5aZXB0byApXG59Il0sImZpbGUiOiJzd2lwZS5taW4uanMiLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
