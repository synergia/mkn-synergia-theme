/*
 * Swipe 2.0
 *
 * Brad Birdsall
 * Copyright 2013, MIT License
 *
*/

function Swipe(container, options) {

  "use strict";

  // utilities
  var noop = function() {}; // simple no operation function
  var offloadFn = function(fn) { setTimeout(fn || noop, 0) }; // offload a functions execution
  
  // check browser capabilities
  var browser = {
    addEventListener: !!window.addEventListener,
    touch: ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch,
    transitions: (function(temp) {
      var props = ['transformProperty', 'WebkitTransform', 'MozTransform', 'OTransform', 'msTransform'];
      for ( var i in props ) if (temp.style[ props[i] ] !== undefined) return true;
      return false;
    })(document.createElement('swipe'))
  };

  // quit if no root element
  if (!container) return;
  var element = container.children[0];
  var slides, slidePos, width;
  options = options || {};
  var index = parseInt(options.startSlide, 10) || 0;
  var speed = options.speed || 300;

  function setup() {

    // cache slides
    slides = element.children;

    // create an array to store current positions of each slide
    slidePos = new Array(slides.length);

    // determine width of each slide
    width = container.getBoundingClientRect().width || container.offsetWidth;

    element.style.width = (slides.length * width) + 'px';

    // stack elements
    var pos = slides.length;
    while(pos--) {

      var slide = slides[pos];

      slide.style.width = width + 'px';
      slide.setAttribute('data-index', pos);

      if (browser.transitions) {
        slide.style.left = (pos * -width) + 'px';
        move(pos, index > pos ? -width : (index < pos ? width : 0), 0);
      }

    }

    if (!browser.transitions) element.style.left = (index * -width) + 'px';

    container.style.visibility = 'visible';

  }

  function prev() {

    if (index) slide(index-1);
    else if (options.continuous) slide(slides.length-1);

  }

  function next() {

    if (index < slides.length - 1) slide(index+1);
    else if (options.continuous) slide(0);

  }

  function slide(to, slideSpeed) {

    // do nothing if already on requested slide
    if (index == to) return;
    
    if (browser.transitions) {

      var diff = Math.abs(index-to) - 1;
      var direction = Math.abs(index-to) / (index-to); // 1:right -1:left

      while (diff--) move((to > index ? to : index) - diff - 1, width * direction, 0);

      move(index, width * direction, slideSpeed || speed);
      move(to, 0, slideSpeed || speed);

    } else {

      animate(index * -width, to * -width, slideSpeed || speed);

    }

    index = to;

    offloadFn(options.callback && options.callback(index, slides[index]));

  }

  function move(index, dist, speed) {

    translate(index, dist, speed);
    slidePos[index] = dist;

  }

  function translate(index, dist, speed) {

    var slide = slides[index];
    var style = slide && slide.style;

    if (!style) return;

    style.webkitTransitionDuration = 
    style.MozTransitionDuration = 
    style.msTransitionDuration = 
    style.OTransitionDuration = 
    style.transitionDuration = speed + 'ms';

    style.webkitTransform = 'translate(' + dist + 'px,0)' + 'translateZ(0)';
    style.msTransform = 
    style.MozTransform = 
    style.OTransform = 'translateX(' + dist + 'px)';

  }

  function animate(from, to, speed) {

    // if not an animation, just reposition
    if (!speed) {
      
      element.style.left = to + 'px';
      return;

    }
    
    var start = +new Date;
    
    var timer = setInterval(function() {

      var timeElap = +new Date - start;
      
      if (timeElap > speed) {

        element.style.left = to + 'px';

        if (delay) begin();

        options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);

        clearInterval(timer);
        return;

      }

      element.style.left = (( (to - from) * (Math.floor((timeElap / speed) * 100) / 100) ) + from) + 'px';

    }, 4);

  }

  // setup auto slideshow
  var delay = options.auto || 0;
  var interval;

  function begin() {

    interval = setTimeout(next, delay);

  }

  function stop() {

    delay = 0;
    clearTimeout(interval);

  }


  // setup initial vars
  var start = {};
  var delta = {};
  var isScrolling;      

  // setup event capturing
  var events = {

    handleEvent: function(event) {

      switch (event.type) {
        case 'touchstart': this.start(event); break;
        case 'touchmove': this.move(event); break;
        case 'touchend': offloadFn(this.end(event)); break;
        case 'webkitTransitionEnd':
        case 'msTransitionEnd':
        case 'oTransitionEnd':
        case 'otransitionend':
        case 'transitionend': offloadFn(this.transitionEnd(event)); break;
        case 'resize': offloadFn(setup.call()); break;
      }

      if (options.stopPropagation) event.stopPropagation();

    },
    start: function(event) {

      var touches = event.touches[0];

      // measure start values
      start = {

        // get initial touch coords
        x: touches.pageX,
        y: touches.pageY,

        // store time to determine touch duration
        time: +new Date

      };
      
      // used for testing first move event
      isScrolling = undefined;

      // reset delta and end measurements
      delta = {};

      // attach touchmove and touchend listeners
      element.addEventListener('touchmove', this, false);
      element.addEventListener('touchend', this, false);

    },
    move: function(event) {

      // ensure swiping with one touch and not pinching
      if ( event.touches.length > 1 || event.scale && event.scale !== 1) return

      if (options.disableScroll) event.preventDefault();

      var touches = event.touches[0];

      // measure change in x and y
      delta = {
        x: touches.pageX - start.x,
        y: touches.pageY - start.y
      }

      // determine if scrolling test has run - one time test
      if ( typeof isScrolling == 'undefined') {
        isScrolling = !!( isScrolling || Math.abs(delta.x) < Math.abs(delta.y) );
      }

      // if user is not trying to scroll vertically
      if (!isScrolling) {

        // prevent native scrolling 
        event.preventDefault();

        // stop slideshow
        stop();

        // increase resistance if first or last slide
        delta.x = 
          delta.x / 
            ( (!index && delta.x > 0               // if first slide and sliding left
              || index == slides.length - 1        // or if last slide and sliding right
              && delta.x < 0                       // and if sliding at all
            ) ?                      
            ( Math.abs(delta.x) / width + 1 )      // determine resistance level
            : 1 );                                 // no resistance if false
        
        // translate 1:1
        translate(index-1, delta.x + slidePos[index-1], 0);
        translate(index, delta.x + slidePos[index], 0);
        translate(index+1, delta.x + slidePos[index+1], 0);

      }

    },
    end: function(event) {

      // measure duration
      var duration = +new Date - start.time;

      // determine if slide attempt triggers next/prev slide
      var isValidSlide = 
            Number(duration) < 250               // if slide duration is less than 250ms
            && Math.abs(delta.x) > 20            // and if slide amt is greater than 20px
            || Math.abs(delta.x) > width/2;      // or if slide amt is greater than half the width

      // determine if slide attempt is past start and end
      var isPastBounds = 
            !index && delta.x > 0                            // if first slide and slide amt is greater than 0
            || index == slides.length - 1 && delta.x < 0;    // or if last slide and slide amt is less than 0
      
      // determine direction of swipe (true:right, false:left)
      var direction = delta.x < 0;

      // if not scrolling vertically
      if (!isScrolling) {

        if (isValidSlide && !isPastBounds) {

          if (direction) {

            move(index-1, -width, 0);
            move(index, slidePos[index]-width, speed);
            move(index+1, slidePos[index+1]-width, speed);
            index += 1;

          } else {

            move(index+1, width, 0);
            move(index, slidePos[index]+width, speed);
            move(index-1, slidePos[index-1]+width, speed);
            index += -1;

          }

          options.callback && options.callback(index, slides[index]);

        } else {

          move(index-1, -width, speed);
          move(index, 0, speed);
          move(index+1, width, speed);

        }

      }

      // kill touchmove and touchend event listeners until touchstart called again
      element.removeEventListener('touchmove', events, false)
      element.removeEventListener('touchend', events, false)

    },
    transitionEnd: function(event) {

      if (parseInt(event.target.getAttribute('data-index'), 10) == index) {
        
        if (delay) begin();

        options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);

      }

    }

  }

  // trigger setup
  setup();

  // start auto slideshow if applicable
  if (delay) begin();


  // add event listeners
  if (browser.addEventListener) {
    
    // set touchstart event on element    
    if (browser.touch) element.addEventListener('touchstart', events, false);

    if (browser.transitions) {
      element.addEventListener('webkitTransitionEnd', events, false);
      element.addEventListener('msTransitionEnd', events, false);
      element.addEventListener('oTransitionEnd', events, false);
      element.addEventListener('otransitionend', events, false);
      element.addEventListener('transitionend', events, false);
    }

    // set resize event on window
    window.addEventListener('resize', events, false);

  } else {

    window.onresize = function () { setup() }; // to play nice with old IE

  }

  // expose the Swipe API
  return {
    setup: function() {

      setup();

    },
    slide: function(to, speed) {

      slide(to, speed);

    },
    prev: function() {

      // cancel slideshow
      stop();

      prev();

    },
    next: function() {

      stop();

      next();

    },
    getPos: function() {

      // return current index position
      return index;

    },
    kill: function() {

      // cancel slideshow
      stop();

      // reset element
      element.style.width = 'auto';
      element.style.left = 0;

      // reset slides
      var pos = slides.length;
      while(pos--) {

        var slide = slides[pos];
        slide.style.width = '100%';
        slide.style.left = 0;

        if (browser.transitions) translate(pos, 0, 0);

      }

      // removed event listeners
      if (browser.addEventListener) {

        // remove current event listeners
        element.removeEventListener('touchstart', events, false);
        element.removeEventListener('webkitTransitionEnd', events, false);
        element.removeEventListener('msTransitionEnd', events, false);
        element.removeEventListener('oTransitionEnd', events, false);
        element.removeEventListener('otransitionend', events, false);
        element.removeEventListener('transitionend', events, false);
        window.removeEventListener('resize', events, false);

      }
      else {

        window.onresize = null;

      }

    }
  }

}


if ( window.jQuery || window.Zepto ) {
  (function($) {
    $.fn.Swipe = function(params) {
      return this.each(function() {
        $(this).data('Swipe', new Swipe($(this)[0], params));
      });
    }
  })( window.jQuery || window.Zepto )
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJzd2lwZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBTd2lwZSAyLjBcclxuICpcclxuICogQnJhZCBCaXJkc2FsbFxyXG4gKiBDb3B5cmlnaHQgMjAxMywgTUlUIExpY2Vuc2VcclxuICpcclxuKi9cclxuXHJcbmZ1bmN0aW9uIFN3aXBlKGNvbnRhaW5lciwgb3B0aW9ucykge1xyXG5cclxuICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgLy8gdXRpbGl0aWVzXHJcbiAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9OyAvLyBzaW1wbGUgbm8gb3BlcmF0aW9uIGZ1bmN0aW9uXHJcbiAgdmFyIG9mZmxvYWRGbiA9IGZ1bmN0aW9uKGZuKSB7IHNldFRpbWVvdXQoZm4gfHwgbm9vcCwgMCkgfTsgLy8gb2ZmbG9hZCBhIGZ1bmN0aW9ucyBleGVjdXRpb25cclxuICBcclxuICAvLyBjaGVjayBicm93c2VyIGNhcGFiaWxpdGllc1xyXG4gIHZhciBicm93c2VyID0ge1xyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogISF3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcixcclxuICAgIHRvdWNoOiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB8fCB3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIERvY3VtZW50VG91Y2gsXHJcbiAgICB0cmFuc2l0aW9uczogKGZ1bmN0aW9uKHRlbXApIHtcclxuICAgICAgdmFyIHByb3BzID0gWyd0cmFuc2Zvcm1Qcm9wZXJ0eScsICdXZWJraXRUcmFuc2Zvcm0nLCAnTW96VHJhbnNmb3JtJywgJ09UcmFuc2Zvcm0nLCAnbXNUcmFuc2Zvcm0nXTtcclxuICAgICAgZm9yICggdmFyIGkgaW4gcHJvcHMgKSBpZiAodGVtcC5zdHlsZVsgcHJvcHNbaV0gXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSkoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3dpcGUnKSlcclxuICB9O1xyXG5cclxuICAvLyBxdWl0IGlmIG5vIHJvb3QgZWxlbWVudFxyXG4gIGlmICghY29udGFpbmVyKSByZXR1cm47XHJcbiAgdmFyIGVsZW1lbnQgPSBjb250YWluZXIuY2hpbGRyZW5bMF07XHJcbiAgdmFyIHNsaWRlcywgc2xpZGVQb3MsIHdpZHRoO1xyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gIHZhciBpbmRleCA9IHBhcnNlSW50KG9wdGlvbnMuc3RhcnRTbGlkZSwgMTApIHx8IDA7XHJcbiAgdmFyIHNwZWVkID0gb3B0aW9ucy5zcGVlZCB8fCAzMDA7XHJcblxyXG4gIGZ1bmN0aW9uIHNldHVwKCkge1xyXG5cclxuICAgIC8vIGNhY2hlIHNsaWRlc1xyXG4gICAgc2xpZGVzID0gZWxlbWVudC5jaGlsZHJlbjtcclxuXHJcbiAgICAvLyBjcmVhdGUgYW4gYXJyYXkgdG8gc3RvcmUgY3VycmVudCBwb3NpdGlvbnMgb2YgZWFjaCBzbGlkZVxyXG4gICAgc2xpZGVQb3MgPSBuZXcgQXJyYXkoc2xpZGVzLmxlbmd0aCk7XHJcblxyXG4gICAgLy8gZGV0ZXJtaW5lIHdpZHRoIG9mIGVhY2ggc2xpZGVcclxuICAgIHdpZHRoID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHx8IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHJcbiAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gKHNsaWRlcy5sZW5ndGggKiB3aWR0aCkgKyAncHgnO1xyXG5cclxuICAgIC8vIHN0YWNrIGVsZW1lbnRzXHJcbiAgICB2YXIgcG9zID0gc2xpZGVzLmxlbmd0aDtcclxuICAgIHdoaWxlKHBvcy0tKSB7XHJcblxyXG4gICAgICB2YXIgc2xpZGUgPSBzbGlkZXNbcG9zXTtcclxuXHJcbiAgICAgIHNsaWRlLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xyXG4gICAgICBzbGlkZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnLCBwb3MpO1xyXG5cclxuICAgICAgaWYgKGJyb3dzZXIudHJhbnNpdGlvbnMpIHtcclxuICAgICAgICBzbGlkZS5zdHlsZS5sZWZ0ID0gKHBvcyAqIC13aWR0aCkgKyAncHgnO1xyXG4gICAgICAgIG1vdmUocG9zLCBpbmRleCA+IHBvcyA/IC13aWR0aCA6IChpbmRleCA8IHBvcyA/IHdpZHRoIDogMCksIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGlmICghYnJvd3Nlci50cmFuc2l0aW9ucykgZWxlbWVudC5zdHlsZS5sZWZ0ID0gKGluZGV4ICogLXdpZHRoKSArICdweCc7XHJcblxyXG4gICAgY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XHJcblxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcHJldigpIHtcclxuXHJcbiAgICBpZiAoaW5kZXgpIHNsaWRlKGluZGV4LTEpO1xyXG4gICAgZWxzZSBpZiAob3B0aW9ucy5jb250aW51b3VzKSBzbGlkZShzbGlkZXMubGVuZ3RoLTEpO1xyXG5cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG5leHQoKSB7XHJcblxyXG4gICAgaWYgKGluZGV4IDwgc2xpZGVzLmxlbmd0aCAtIDEpIHNsaWRlKGluZGV4KzEpO1xyXG4gICAgZWxzZSBpZiAob3B0aW9ucy5jb250aW51b3VzKSBzbGlkZSgwKTtcclxuXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzbGlkZSh0bywgc2xpZGVTcGVlZCkge1xyXG5cclxuICAgIC8vIGRvIG5vdGhpbmcgaWYgYWxyZWFkeSBvbiByZXF1ZXN0ZWQgc2xpZGVcclxuICAgIGlmIChpbmRleCA9PSB0bykgcmV0dXJuO1xyXG4gICAgXHJcbiAgICBpZiAoYnJvd3Nlci50cmFuc2l0aW9ucykge1xyXG5cclxuICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhpbmRleC10bykgLSAxO1xyXG4gICAgICB2YXIgZGlyZWN0aW9uID0gTWF0aC5hYnMoaW5kZXgtdG8pIC8gKGluZGV4LXRvKTsgLy8gMTpyaWdodCAtMTpsZWZ0XHJcblxyXG4gICAgICB3aGlsZSAoZGlmZi0tKSBtb3ZlKCh0byA+IGluZGV4ID8gdG8gOiBpbmRleCkgLSBkaWZmIC0gMSwgd2lkdGggKiBkaXJlY3Rpb24sIDApO1xyXG5cclxuICAgICAgbW92ZShpbmRleCwgd2lkdGggKiBkaXJlY3Rpb24sIHNsaWRlU3BlZWQgfHwgc3BlZWQpO1xyXG4gICAgICBtb3ZlKHRvLCAwLCBzbGlkZVNwZWVkIHx8IHNwZWVkKTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgYW5pbWF0ZShpbmRleCAqIC13aWR0aCwgdG8gKiAtd2lkdGgsIHNsaWRlU3BlZWQgfHwgc3BlZWQpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBpbmRleCA9IHRvO1xyXG5cclxuICAgIG9mZmxvYWRGbihvcHRpb25zLmNhbGxiYWNrICYmIG9wdGlvbnMuY2FsbGJhY2soaW5kZXgsIHNsaWRlc1tpbmRleF0pKTtcclxuXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBtb3ZlKGluZGV4LCBkaXN0LCBzcGVlZCkge1xyXG5cclxuICAgIHRyYW5zbGF0ZShpbmRleCwgZGlzdCwgc3BlZWQpO1xyXG4gICAgc2xpZGVQb3NbaW5kZXhdID0gZGlzdDtcclxuXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0cmFuc2xhdGUoaW5kZXgsIGRpc3QsIHNwZWVkKSB7XHJcblxyXG4gICAgdmFyIHNsaWRlID0gc2xpZGVzW2luZGV4XTtcclxuICAgIHZhciBzdHlsZSA9IHNsaWRlICYmIHNsaWRlLnN0eWxlO1xyXG5cclxuICAgIGlmICghc3R5bGUpIHJldHVybjtcclxuXHJcbiAgICBzdHlsZS53ZWJraXRUcmFuc2l0aW9uRHVyYXRpb24gPSBcclxuICAgIHN0eWxlLk1velRyYW5zaXRpb25EdXJhdGlvbiA9IFxyXG4gICAgc3R5bGUubXNUcmFuc2l0aW9uRHVyYXRpb24gPSBcclxuICAgIHN0eWxlLk9UcmFuc2l0aW9uRHVyYXRpb24gPSBcclxuICAgIHN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IHNwZWVkICsgJ21zJztcclxuXHJcbiAgICBzdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAndHJhbnNsYXRlKCcgKyBkaXN0ICsgJ3B4LDApJyArICd0cmFuc2xhdGVaKDApJztcclxuICAgIHN0eWxlLm1zVHJhbnNmb3JtID0gXHJcbiAgICBzdHlsZS5Nb3pUcmFuc2Zvcm0gPSBcclxuICAgIHN0eWxlLk9UcmFuc2Zvcm0gPSAndHJhbnNsYXRlWCgnICsgZGlzdCArICdweCknO1xyXG5cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFuaW1hdGUoZnJvbSwgdG8sIHNwZWVkKSB7XHJcblxyXG4gICAgLy8gaWYgbm90IGFuIGFuaW1hdGlvbiwganVzdCByZXBvc2l0aW9uXHJcbiAgICBpZiAoIXNwZWVkKSB7XHJcbiAgICAgIFxyXG4gICAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSB0byArICdweCc7XHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciBzdGFydCA9ICtuZXcgRGF0ZTtcclxuICAgIFxyXG4gICAgdmFyIHRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICB2YXIgdGltZUVsYXAgPSArbmV3IERhdGUgLSBzdGFydDtcclxuICAgICAgXHJcbiAgICAgIGlmICh0aW1lRWxhcCA+IHNwZWVkKSB7XHJcblxyXG4gICAgICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9IHRvICsgJ3B4JztcclxuXHJcbiAgICAgICAgaWYgKGRlbGF5KSBiZWdpbigpO1xyXG5cclxuICAgICAgICBvcHRpb25zLnRyYW5zaXRpb25FbmQgJiYgb3B0aW9ucy50cmFuc2l0aW9uRW5kLmNhbGwoZXZlbnQsIGluZGV4LCBzbGlkZXNbaW5kZXhdKTtcclxuXHJcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgfVxyXG5cclxuICAgICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gKCggKHRvIC0gZnJvbSkgKiAoTWF0aC5mbG9vcigodGltZUVsYXAgLyBzcGVlZCkgKiAxMDApIC8gMTAwKSApICsgZnJvbSkgKyAncHgnO1xyXG5cclxuICAgIH0sIDQpO1xyXG5cclxuICB9XHJcblxyXG4gIC8vIHNldHVwIGF1dG8gc2xpZGVzaG93XHJcbiAgdmFyIGRlbGF5ID0gb3B0aW9ucy5hdXRvIHx8IDA7XHJcbiAgdmFyIGludGVydmFsO1xyXG5cclxuICBmdW5jdGlvbiBiZWdpbigpIHtcclxuXHJcbiAgICBpbnRlcnZhbCA9IHNldFRpbWVvdXQobmV4dCwgZGVsYXkpO1xyXG5cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHN0b3AoKSB7XHJcblxyXG4gICAgZGVsYXkgPSAwO1xyXG4gICAgY2xlYXJUaW1lb3V0KGludGVydmFsKTtcclxuXHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gc2V0dXAgaW5pdGlhbCB2YXJzXHJcbiAgdmFyIHN0YXJ0ID0ge307XHJcbiAgdmFyIGRlbHRhID0ge307XHJcbiAgdmFyIGlzU2Nyb2xsaW5nOyAgICAgIFxyXG5cclxuICAvLyBzZXR1cCBldmVudCBjYXB0dXJpbmdcclxuICB2YXIgZXZlbnRzID0ge1xyXG5cclxuICAgIGhhbmRsZUV2ZW50OiBmdW5jdGlvbihldmVudCkge1xyXG5cclxuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XHJcbiAgICAgICAgY2FzZSAndG91Y2hzdGFydCc6IHRoaXMuc3RhcnQoZXZlbnQpOyBicmVhaztcclxuICAgICAgICBjYXNlICd0b3VjaG1vdmUnOiB0aGlzLm1vdmUoZXZlbnQpOyBicmVhaztcclxuICAgICAgICBjYXNlICd0b3VjaGVuZCc6IG9mZmxvYWRGbih0aGlzLmVuZChldmVudCkpOyBicmVhaztcclxuICAgICAgICBjYXNlICd3ZWJraXRUcmFuc2l0aW9uRW5kJzpcclxuICAgICAgICBjYXNlICdtc1RyYW5zaXRpb25FbmQnOlxyXG4gICAgICAgIGNhc2UgJ29UcmFuc2l0aW9uRW5kJzpcclxuICAgICAgICBjYXNlICdvdHJhbnNpdGlvbmVuZCc6XHJcbiAgICAgICAgY2FzZSAndHJhbnNpdGlvbmVuZCc6IG9mZmxvYWRGbih0aGlzLnRyYW5zaXRpb25FbmQoZXZlbnQpKTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAncmVzaXplJzogb2ZmbG9hZEZuKHNldHVwLmNhbGwoKSk7IGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAob3B0aW9ucy5zdG9wUHJvcGFnYXRpb24pIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgIH0sXHJcbiAgICBzdGFydDogZnVuY3Rpb24oZXZlbnQpIHtcclxuXHJcbiAgICAgIHZhciB0b3VjaGVzID0gZXZlbnQudG91Y2hlc1swXTtcclxuXHJcbiAgICAgIC8vIG1lYXN1cmUgc3RhcnQgdmFsdWVzXHJcbiAgICAgIHN0YXJ0ID0ge1xyXG5cclxuICAgICAgICAvLyBnZXQgaW5pdGlhbCB0b3VjaCBjb29yZHNcclxuICAgICAgICB4OiB0b3VjaGVzLnBhZ2VYLFxyXG4gICAgICAgIHk6IHRvdWNoZXMucGFnZVksXHJcblxyXG4gICAgICAgIC8vIHN0b3JlIHRpbWUgdG8gZGV0ZXJtaW5lIHRvdWNoIGR1cmF0aW9uXHJcbiAgICAgICAgdGltZTogK25ldyBEYXRlXHJcblxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgLy8gdXNlZCBmb3IgdGVzdGluZyBmaXJzdCBtb3ZlIGV2ZW50XHJcbiAgICAgIGlzU2Nyb2xsaW5nID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgLy8gcmVzZXQgZGVsdGEgYW5kIGVuZCBtZWFzdXJlbWVudHNcclxuICAgICAgZGVsdGEgPSB7fTtcclxuXHJcbiAgICAgIC8vIGF0dGFjaCB0b3VjaG1vdmUgYW5kIHRvdWNoZW5kIGxpc3RlbmVyc1xyXG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMsIGZhbHNlKTtcclxuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMsIGZhbHNlKTtcclxuXHJcbiAgICB9LFxyXG4gICAgbW92ZTogZnVuY3Rpb24oZXZlbnQpIHtcclxuXHJcbiAgICAgIC8vIGVuc3VyZSBzd2lwaW5nIHdpdGggb25lIHRvdWNoIGFuZCBub3QgcGluY2hpbmdcclxuICAgICAgaWYgKCBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEgfHwgZXZlbnQuc2NhbGUgJiYgZXZlbnQuc2NhbGUgIT09IDEpIHJldHVyblxyXG5cclxuICAgICAgaWYgKG9wdGlvbnMuZGlzYWJsZVNjcm9sbCkgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgIHZhciB0b3VjaGVzID0gZXZlbnQudG91Y2hlc1swXTtcclxuXHJcbiAgICAgIC8vIG1lYXN1cmUgY2hhbmdlIGluIHggYW5kIHlcclxuICAgICAgZGVsdGEgPSB7XHJcbiAgICAgICAgeDogdG91Y2hlcy5wYWdlWCAtIHN0YXJ0LngsXHJcbiAgICAgICAgeTogdG91Y2hlcy5wYWdlWSAtIHN0YXJ0LnlcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZGV0ZXJtaW5lIGlmIHNjcm9sbGluZyB0ZXN0IGhhcyBydW4gLSBvbmUgdGltZSB0ZXN0XHJcbiAgICAgIGlmICggdHlwZW9mIGlzU2Nyb2xsaW5nID09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgaXNTY3JvbGxpbmcgPSAhISggaXNTY3JvbGxpbmcgfHwgTWF0aC5hYnMoZGVsdGEueCkgPCBNYXRoLmFicyhkZWx0YS55KSApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBpZiB1c2VyIGlzIG5vdCB0cnlpbmcgdG8gc2Nyb2xsIHZlcnRpY2FsbHlcclxuICAgICAgaWYgKCFpc1Njcm9sbGluZykge1xyXG5cclxuICAgICAgICAvLyBwcmV2ZW50IG5hdGl2ZSBzY3JvbGxpbmcgXHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgLy8gc3RvcCBzbGlkZXNob3dcclxuICAgICAgICBzdG9wKCk7XHJcblxyXG4gICAgICAgIC8vIGluY3JlYXNlIHJlc2lzdGFuY2UgaWYgZmlyc3Qgb3IgbGFzdCBzbGlkZVxyXG4gICAgICAgIGRlbHRhLnggPSBcclxuICAgICAgICAgIGRlbHRhLnggLyBcclxuICAgICAgICAgICAgKCAoIWluZGV4ICYmIGRlbHRhLnggPiAwICAgICAgICAgICAgICAgLy8gaWYgZmlyc3Qgc2xpZGUgYW5kIHNsaWRpbmcgbGVmdFxyXG4gICAgICAgICAgICAgIHx8IGluZGV4ID09IHNsaWRlcy5sZW5ndGggLSAxICAgICAgICAvLyBvciBpZiBsYXN0IHNsaWRlIGFuZCBzbGlkaW5nIHJpZ2h0XHJcbiAgICAgICAgICAgICAgJiYgZGVsdGEueCA8IDAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBpZiBzbGlkaW5nIGF0IGFsbFxyXG4gICAgICAgICAgICApID8gICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICggTWF0aC5hYnMoZGVsdGEueCkgLyB3aWR0aCArIDEgKSAgICAgIC8vIGRldGVybWluZSByZXNpc3RhbmNlIGxldmVsXHJcbiAgICAgICAgICAgIDogMSApOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIHJlc2lzdGFuY2UgaWYgZmFsc2VcclxuICAgICAgICBcclxuICAgICAgICAvLyB0cmFuc2xhdGUgMToxXHJcbiAgICAgICAgdHJhbnNsYXRlKGluZGV4LTEsIGRlbHRhLnggKyBzbGlkZVBvc1tpbmRleC0xXSwgMCk7XHJcbiAgICAgICAgdHJhbnNsYXRlKGluZGV4LCBkZWx0YS54ICsgc2xpZGVQb3NbaW5kZXhdLCAwKTtcclxuICAgICAgICB0cmFuc2xhdGUoaW5kZXgrMSwgZGVsdGEueCArIHNsaWRlUG9zW2luZGV4KzFdLCAwKTtcclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICB9LFxyXG4gICAgZW5kOiBmdW5jdGlvbihldmVudCkge1xyXG5cclxuICAgICAgLy8gbWVhc3VyZSBkdXJhdGlvblxyXG4gICAgICB2YXIgZHVyYXRpb24gPSArbmV3IERhdGUgLSBzdGFydC50aW1lO1xyXG5cclxuICAgICAgLy8gZGV0ZXJtaW5lIGlmIHNsaWRlIGF0dGVtcHQgdHJpZ2dlcnMgbmV4dC9wcmV2IHNsaWRlXHJcbiAgICAgIHZhciBpc1ZhbGlkU2xpZGUgPSBcclxuICAgICAgICAgICAgTnVtYmVyKGR1cmF0aW9uKSA8IDI1MCAgICAgICAgICAgICAgIC8vIGlmIHNsaWRlIGR1cmF0aW9uIGlzIGxlc3MgdGhhbiAyNTBtc1xyXG4gICAgICAgICAgICAmJiBNYXRoLmFicyhkZWx0YS54KSA+IDIwICAgICAgICAgICAgLy8gYW5kIGlmIHNsaWRlIGFtdCBpcyBncmVhdGVyIHRoYW4gMjBweFxyXG4gICAgICAgICAgICB8fCBNYXRoLmFicyhkZWx0YS54KSA+IHdpZHRoLzI7ICAgICAgLy8gb3IgaWYgc2xpZGUgYW10IGlzIGdyZWF0ZXIgdGhhbiBoYWxmIHRoZSB3aWR0aFxyXG5cclxuICAgICAgLy8gZGV0ZXJtaW5lIGlmIHNsaWRlIGF0dGVtcHQgaXMgcGFzdCBzdGFydCBhbmQgZW5kXHJcbiAgICAgIHZhciBpc1Bhc3RCb3VuZHMgPSBcclxuICAgICAgICAgICAgIWluZGV4ICYmIGRlbHRhLnggPiAwICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGZpcnN0IHNsaWRlIGFuZCBzbGlkZSBhbXQgaXMgZ3JlYXRlciB0aGFuIDBcclxuICAgICAgICAgICAgfHwgaW5kZXggPT0gc2xpZGVzLmxlbmd0aCAtIDEgJiYgZGVsdGEueCA8IDA7ICAgIC8vIG9yIGlmIGxhc3Qgc2xpZGUgYW5kIHNsaWRlIGFtdCBpcyBsZXNzIHRoYW4gMFxyXG4gICAgICBcclxuICAgICAgLy8gZGV0ZXJtaW5lIGRpcmVjdGlvbiBvZiBzd2lwZSAodHJ1ZTpyaWdodCwgZmFsc2U6bGVmdClcclxuICAgICAgdmFyIGRpcmVjdGlvbiA9IGRlbHRhLnggPCAwO1xyXG5cclxuICAgICAgLy8gaWYgbm90IHNjcm9sbGluZyB2ZXJ0aWNhbGx5XHJcbiAgICAgIGlmICghaXNTY3JvbGxpbmcpIHtcclxuXHJcbiAgICAgICAgaWYgKGlzVmFsaWRTbGlkZSAmJiAhaXNQYXN0Qm91bmRzKSB7XHJcblxyXG4gICAgICAgICAgaWYgKGRpcmVjdGlvbikge1xyXG5cclxuICAgICAgICAgICAgbW92ZShpbmRleC0xLCAtd2lkdGgsIDApO1xyXG4gICAgICAgICAgICBtb3ZlKGluZGV4LCBzbGlkZVBvc1tpbmRleF0td2lkdGgsIHNwZWVkKTtcclxuICAgICAgICAgICAgbW92ZShpbmRleCsxLCBzbGlkZVBvc1tpbmRleCsxXS13aWR0aCwgc3BlZWQpO1xyXG4gICAgICAgICAgICBpbmRleCArPSAxO1xyXG5cclxuICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBtb3ZlKGluZGV4KzEsIHdpZHRoLCAwKTtcclxuICAgICAgICAgICAgbW92ZShpbmRleCwgc2xpZGVQb3NbaW5kZXhdK3dpZHRoLCBzcGVlZCk7XHJcbiAgICAgICAgICAgIG1vdmUoaW5kZXgtMSwgc2xpZGVQb3NbaW5kZXgtMV0rd2lkdGgsIHNwZWVkKTtcclxuICAgICAgICAgICAgaW5kZXggKz0gLTE7XHJcblxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2sgJiYgb3B0aW9ucy5jYWxsYmFjayhpbmRleCwgc2xpZGVzW2luZGV4XSk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgbW92ZShpbmRleC0xLCAtd2lkdGgsIHNwZWVkKTtcclxuICAgICAgICAgIG1vdmUoaW5kZXgsIDAsIHNwZWVkKTtcclxuICAgICAgICAgIG1vdmUoaW5kZXgrMSwgd2lkdGgsIHNwZWVkKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8ga2lsbCB0b3VjaG1vdmUgYW5kIHRvdWNoZW5kIGV2ZW50IGxpc3RlbmVycyB1bnRpbCB0b3VjaHN0YXJ0IGNhbGxlZCBhZ2FpblxyXG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGV2ZW50cywgZmFsc2UpXHJcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBldmVudHMsIGZhbHNlKVxyXG5cclxuICAgIH0sXHJcbiAgICB0cmFuc2l0aW9uRW5kOiBmdW5jdGlvbihldmVudCkge1xyXG5cclxuICAgICAgaWYgKHBhcnNlSW50KGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnKSwgMTApID09IGluZGV4KSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGRlbGF5KSBiZWdpbigpO1xyXG5cclxuICAgICAgICBvcHRpb25zLnRyYW5zaXRpb25FbmQgJiYgb3B0aW9ucy50cmFuc2l0aW9uRW5kLmNhbGwoZXZlbnQsIGluZGV4LCBzbGlkZXNbaW5kZXhdKTtcclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcbiAgLy8gdHJpZ2dlciBzZXR1cFxyXG4gIHNldHVwKCk7XHJcblxyXG4gIC8vIHN0YXJ0IGF1dG8gc2xpZGVzaG93IGlmIGFwcGxpY2FibGVcclxuICBpZiAoZGVsYXkpIGJlZ2luKCk7XHJcblxyXG5cclxuICAvLyBhZGQgZXZlbnQgbGlzdGVuZXJzXHJcbiAgaWYgKGJyb3dzZXIuYWRkRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgXHJcbiAgICAvLyBzZXQgdG91Y2hzdGFydCBldmVudCBvbiBlbGVtZW50ICAgIFxyXG4gICAgaWYgKGJyb3dzZXIudG91Y2gpIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGV2ZW50cywgZmFsc2UpO1xyXG5cclxuICAgIGlmIChicm93c2VyLnRyYW5zaXRpb25zKSB7XHJcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0VHJhbnNpdGlvbkVuZCcsIGV2ZW50cywgZmFsc2UpO1xyXG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21zVHJhbnNpdGlvbkVuZCcsIGV2ZW50cywgZmFsc2UpO1xyXG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ29UcmFuc2l0aW9uRW5kJywgZXZlbnRzLCBmYWxzZSk7XHJcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignb3RyYW5zaXRpb25lbmQnLCBldmVudHMsIGZhbHNlKTtcclxuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZXZlbnRzLCBmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2V0IHJlc2l6ZSBldmVudCBvbiB3aW5kb3dcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBldmVudHMsIGZhbHNlKTtcclxuXHJcbiAgfSBlbHNlIHtcclxuXHJcbiAgICB3aW5kb3cub25yZXNpemUgPSBmdW5jdGlvbiAoKSB7IHNldHVwKCkgfTsgLy8gdG8gcGxheSBuaWNlIHdpdGggb2xkIElFXHJcblxyXG4gIH1cclxuXHJcbiAgLy8gZXhwb3NlIHRoZSBTd2lwZSBBUElcclxuICByZXR1cm4ge1xyXG4gICAgc2V0dXA6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgc2V0dXAoKTtcclxuXHJcbiAgICB9LFxyXG4gICAgc2xpZGU6IGZ1bmN0aW9uKHRvLCBzcGVlZCkge1xyXG5cclxuICAgICAgc2xpZGUodG8sIHNwZWVkKTtcclxuXHJcbiAgICB9LFxyXG4gICAgcHJldjogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAvLyBjYW5jZWwgc2xpZGVzaG93XHJcbiAgICAgIHN0b3AoKTtcclxuXHJcbiAgICAgIHByZXYoKTtcclxuXHJcbiAgICB9LFxyXG4gICAgbmV4dDogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICBzdG9wKCk7XHJcblxyXG4gICAgICBuZXh0KCk7XHJcblxyXG4gICAgfSxcclxuICAgIGdldFBvczogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAvLyByZXR1cm4gY3VycmVudCBpbmRleCBwb3NpdGlvblxyXG4gICAgICByZXR1cm4gaW5kZXg7XHJcblxyXG4gICAgfSxcclxuICAgIGtpbGw6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgLy8gY2FuY2VsIHNsaWRlc2hvd1xyXG4gICAgICBzdG9wKCk7XHJcblxyXG4gICAgICAvLyByZXNldCBlbGVtZW50XHJcbiAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSAnYXV0byc7XHJcbiAgICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9IDA7XHJcblxyXG4gICAgICAvLyByZXNldCBzbGlkZXNcclxuICAgICAgdmFyIHBvcyA9IHNsaWRlcy5sZW5ndGg7XHJcbiAgICAgIHdoaWxlKHBvcy0tKSB7XHJcblxyXG4gICAgICAgIHZhciBzbGlkZSA9IHNsaWRlc1twb3NdO1xyXG4gICAgICAgIHNsaWRlLnN0eWxlLndpZHRoID0gJzEwMCUnO1xyXG4gICAgICAgIHNsaWRlLnN0eWxlLmxlZnQgPSAwO1xyXG5cclxuICAgICAgICBpZiAoYnJvd3Nlci50cmFuc2l0aW9ucykgdHJhbnNsYXRlKHBvcywgMCwgMCk7XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyByZW1vdmVkIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgICBpZiAoYnJvd3Nlci5hZGRFdmVudExpc3RlbmVyKSB7XHJcblxyXG4gICAgICAgIC8vIHJlbW92ZSBjdXJyZW50IGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGV2ZW50cywgZmFsc2UpO1xyXG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0VHJhbnNpdGlvbkVuZCcsIGV2ZW50cywgZmFsc2UpO1xyXG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbXNUcmFuc2l0aW9uRW5kJywgZXZlbnRzLCBmYWxzZSk7XHJcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdvVHJhbnNpdGlvbkVuZCcsIGV2ZW50cywgZmFsc2UpO1xyXG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3RyYW5zaXRpb25lbmQnLCBldmVudHMsIGZhbHNlKTtcclxuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBldmVudHMsIGZhbHNlKTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZXZlbnRzLCBmYWxzZSk7XHJcblxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICB3aW5kb3cub25yZXNpemUgPSBudWxsO1xyXG5cclxuICAgICAgfVxyXG5cclxuICAgIH1cclxuICB9XHJcblxyXG59XHJcblxyXG5cclxuaWYgKCB3aW5kb3cualF1ZXJ5IHx8IHdpbmRvdy5aZXB0byApIHtcclxuICAoZnVuY3Rpb24oJCkge1xyXG4gICAgJC5mbi5Td2lwZSA9IGZ1bmN0aW9uKHBhcmFtcykge1xyXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICQodGhpcykuZGF0YSgnU3dpcGUnLCBuZXcgU3dpcGUoJCh0aGlzKVswXSwgcGFyYW1zKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pKCB3aW5kb3cualF1ZXJ5IHx8IHdpbmRvdy5aZXB0byApXHJcbn0iXSwiZmlsZSI6InN3aXBlLm1pbi5qcyIsInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
