/*!
  hey, [be]Lazy.js - v1.5.4 - 2016.03.06
  A fast, small and dependency free lazy load script (https://github.com/dinbror/blazy)
  (c) Bjoern Klinggaard - @bklinggaard - http://dinbror.dk/blazy
*/
;
(function(root, blazy) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register bLazy as an anonymous module
        define(blazy);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = blazy();
    } else {
        // Browser globals. Register bLazy on window
        root.Blazy = blazy();
    }
})(this, function() {
    'use strict';

    //private vars
    var source, viewport, isRetina;

    // constructor
    return function Blazy(options) {
        //IE7- fallback for missing querySelectorAll support
        if (!document.querySelectorAll) {
            var s = document.createStyleSheet();
            document.querySelectorAll = function(r, c, i, j, a) {
                a = document.all, c = [], r = r.replace(/\[for\b/gi, '[htmlFor').split(',');
                for (i = r.length; i--;) {
                    s.addRule(r[i], 'k:v');
                    for (j = a.length; j--;) a[j].currentStyle.k && c.push(a[j]);
                    s.removeRule(0);
                }
                return c;
            };
        }

        //options and helper vars
        var scope = this;
        var util = scope._util = {};
        util.elements = [];
        util.destroyed = true;
        scope.options = options || {};
        scope.options.error = scope.options.error || false;
        scope.options.offset = scope.options.offset || 100;
        scope.options.success = scope.options.success || false;
        scope.options.selector = scope.options.selector || '.b-lazy';
        scope.options.separator = scope.options.separator || '|';
        scope.options.container = scope.options.container ? document.querySelectorAll(scope.options.container) : false;
        scope.options.errorClass = scope.options.errorClass || 'b-error';
        scope.options.breakpoints = scope.options.breakpoints || false;
        scope.options.loadInvisible = scope.options.loadInvisible || false;
        scope.options.successClass = scope.options.successClass || 'b-loaded';
        scope.options.validateDelay = scope.options.validateDelay || 25;
        scope.options.saveViewportOffsetDelay = scope.options.saveViewportOffsetDelay || 50;
        scope.options.src = source = scope.options.src || 'data-src';
        isRetina = window.devicePixelRatio > 1;
        viewport = {};
        viewport.top = 0 - scope.options.offset;
        viewport.left = 0 - scope.options.offset;


        /* public functions
         ************************************/
        scope.revalidate = function() {
            initialize(this);
        };
        scope.load = function(elements, force) {
            var opt = this.options;
            if (elements.length === undefined) {
                loadElement(elements, force, opt);
            } else {
                each(elements, function(element) {
                    loadElement(element, force, opt);
                });
            }
        };
        scope.destroy = function() {
            var self = this;
            var util = self._util;
            if (self.options.container) {
                each(self.options.container, function(object) {
                    unbindEvent(object, 'scroll', util.validateT);
                });
            }
            unbindEvent(window, 'scroll', util.validateT);
            unbindEvent(window, 'resize', util.validateT);
            unbindEvent(window, 'resize', util.saveViewportOffsetT);
            util.count = 0;
            util.elements.length = 0;
            util.destroyed = true;
        };

        //throttle, ensures that we don't call the functions too often
        util.validateT = throttle(function() {
            validate(scope);
        }, scope.options.validateDelay, scope);
        util.saveViewportOffsetT = throttle(function() {
            saveViewportOffset(scope.options.offset);
        }, scope.options.saveViewportOffsetDelay, scope);
        saveViewportOffset(scope.options.offset);

        //handle multi-served image src
        each(scope.options.breakpoints, function(object) {
            if (object.width >= window.screen.width) {
                source = object.src;
                return false;
            }
        });

        // start lazy load
        initialize(scope);
    };


    /* Private helper functions
     ************************************/
    function initialize(self) {
        setTimeout(function() {
            var util = self._util;
            // First we create an array of elements to lazy load
            util.elements = toArray(self.options.selector);
            util.count = util.elements.length;
            // Then we bind resize and scroll events if not already binded
            if (util.destroyed) {
                util.destroyed = false;
                if (self.options.container) {
                    each(self.options.container, function(object) {
                        bindEvent(object, 'scroll', util.validateT);
                    });
                }
                bindEvent(window, 'resize', util.saveViewportOffsetT);
                bindEvent(window, 'resize', util.validateT);
                bindEvent(window, 'scroll', util.validateT);
            }
            // And finally, we start to lazy load.
            validate(self);
        }, 1); // "dom ready" fix
    }

    function validate(self) {
        var util = self._util;
        for (var i = 0; i < util.count; i++) {
            var element = util.elements[i];
            if (elementInView(element) || hasClass(element, self.options.successClass)) {
                self.load(element);
                util.elements.splice(i, 1);
                util.count--;
                i--;
            }
        }
        if (util.count === 0) {
            self.destroy();
        }
    }

    function elementInView(ele) {
        var rect = ele.getBoundingClientRect();
        return (
            // Intersection
            rect.right >= viewport.left && rect.bottom >= viewport.top && rect.left <= viewport.right && rect.top <= viewport.bottom
        );
    }

    function loadElement(ele, force, options) {
        // if element is visible, not loaded or forced
        if (!hasClass(ele, options.successClass) && (force || options.loadInvisible || (ele.offsetWidth > 0 && ele.offsetHeight > 0))) {
            var dataSrc = ele.getAttribute(source) || ele.getAttribute(options.src); // fallback to default 'data-src'
            if (dataSrc) {
                var dataSrcSplitted = dataSrc.split(options.separator);
                var src = dataSrcSplitted[isRetina && dataSrcSplitted.length > 1 ? 1 : 0];
                var isImage = ele.nodeName.toLowerCase() === 'img';
                // Image or background image
                if (isImage || ele.src === undefined) {
                    var img = new Image();
                    img.onerror = function() {
                        if (options.error) options.error(ele, "invalid");
                        addClass(ele, options.errorClass);
                    };
                    img.onload = function() {
                        // Is element an image or should we add the src as a background image?
                        isImage ? ele.src = src : ele.style.backgroundImage = 'url("' + src + '")';
                        itemLoaded(ele, options);
                    };
                    img.src = src; //preload
                    // An item with src like iframe, unity, video etc
                } else {
                    ele.src = src;
                    itemLoaded(ele, options);
                }
            } else {
                if (options.error) options.error(ele, "missing");
                if (!hasClass(ele, options.errorClass)) addClass(ele, options.errorClass);
            }
        }
    }

    function itemLoaded(ele, options) {
        addClass(ele, options.successClass);
        if (options.success) options.success(ele);
        // cleanup markup, remove data source attributes
        each(options.breakpoints, function(object) {
            ele.removeAttribute(object.src);
        });
        ele.removeAttribute(options.src);
    }

    function hasClass(ele, className) {
        return (' ' + ele.className + ' ').indexOf(' ' + className + ' ') !== -1;
    }

    function addClass(ele, className) {
        ele.className = ele.className + ' ' + className;
    }

    function toArray(selector) {
        var array = [];
        var nodelist = document.querySelectorAll(selector);
        for (var i = nodelist.length; i--; array.unshift(nodelist[i])) {}
        return array;
    }

    function saveViewportOffset(offset) {
        viewport.bottom = (window.innerHeight || document.documentElement.clientHeight) + offset;
        viewport.right = (window.innerWidth || document.documentElement.clientWidth) + offset;
    }

    function bindEvent(ele, type, fn) {
        if (ele.attachEvent) {
            ele.attachEvent && ele.attachEvent('on' + type, fn);
        } else {
            ele.addEventListener(type, fn, false);
        }
    }

    function unbindEvent(ele, type, fn) {
        if (ele.detachEvent) {
            ele.detachEvent && ele.detachEvent('on' + type, fn);
        } else {
            ele.removeEventListener(type, fn, false);
        }
    }

    function each(object, fn) {
        if (object && fn) {
            var l = object.length;
            for (var i = 0; i < l && fn(object[i], i) !== false; i++) {}
        }
    }

    function throttle(fn, minDelay, scope) {
        var lastCall = 0;
        return function() {
            var now = +new Date();
            if (now - lastCall < minDelay) {
                return;
            }
            lastCall = now;
            fn.apply(scope, arguments);
        };
    }
});
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJibGF6eS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAgaGV5LCBbYmVdTGF6eS5qcyAtIHYxLjUuNCAtIDIwMTYuMDMuMDZcbiAgQSBmYXN0LCBzbWFsbCBhbmQgZGVwZW5kZW5jeSBmcmVlIGxhenkgbG9hZCBzY3JpcHQgKGh0dHBzOi8vZ2l0aHViLmNvbS9kaW5icm9yL2JsYXp5KVxuICAoYykgQmpvZXJuIEtsaW5nZ2FhcmQgLSBAYmtsaW5nZ2FhcmQgLSBodHRwOi8vZGluYnJvci5kay9ibGF6eVxuKi9cbjtcbihmdW5jdGlvbihyb290LCBibGF6eSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBiTGF6eSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlXG4gICAgICAgIGRlZmluZShibGF6eSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gYmxhenkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHMuIFJlZ2lzdGVyIGJMYXp5IG9uIHdpbmRvd1xuICAgICAgICByb290LkJsYXp5ID0gYmxhenkoKTtcbiAgICB9XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvL3ByaXZhdGUgdmFyc1xuICAgIHZhciBzb3VyY2UsIHZpZXdwb3J0LCBpc1JldGluYTtcblxuICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgcmV0dXJuIGZ1bmN0aW9uIEJsYXp5KG9wdGlvbnMpIHtcbiAgICAgICAgLy9JRTctIGZhbGxiYWNrIGZvciBtaXNzaW5nIHF1ZXJ5U2VsZWN0b3JBbGwgc3VwcG9ydFxuICAgICAgICBpZiAoIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwpIHtcbiAgICAgICAgICAgIHZhciBzID0gZG9jdW1lbnQuY3JlYXRlU3R5bGVTaGVldCgpO1xuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCA9IGZ1bmN0aW9uKHIsIGMsIGksIGosIGEpIHtcbiAgICAgICAgICAgICAgICBhID0gZG9jdW1lbnQuYWxsLCBjID0gW10sIHIgPSByLnJlcGxhY2UoL1xcW2ZvclxcYi9naSwgJ1todG1sRm9yJykuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSByLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgICAgICAgICBzLmFkZFJ1bGUocltpXSwgJ2s6dicpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBhLmxlbmd0aDsgai0tOykgYVtqXS5jdXJyZW50U3R5bGUuayAmJiBjLnB1c2goYVtqXSk7XG4gICAgICAgICAgICAgICAgICAgIHMucmVtb3ZlUnVsZSgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9vcHRpb25zIGFuZCBoZWxwZXIgdmFyc1xuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgICAgICB2YXIgdXRpbCA9IHNjb3BlLl91dGlsID0ge307XG4gICAgICAgIHV0aWwuZWxlbWVudHMgPSBbXTtcbiAgICAgICAgdXRpbC5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICBzY29wZS5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgc2NvcGUub3B0aW9ucy5lcnJvciA9IHNjb3BlLm9wdGlvbnMuZXJyb3IgfHwgZmFsc2U7XG4gICAgICAgIHNjb3BlLm9wdGlvbnMub2Zmc2V0ID0gc2NvcGUub3B0aW9ucy5vZmZzZXQgfHwgMTAwO1xuICAgICAgICBzY29wZS5vcHRpb25zLnN1Y2Nlc3MgPSBzY29wZS5vcHRpb25zLnN1Y2Nlc3MgfHwgZmFsc2U7XG4gICAgICAgIHNjb3BlLm9wdGlvbnMuc2VsZWN0b3IgPSBzY29wZS5vcHRpb25zLnNlbGVjdG9yIHx8ICcuYi1sYXp5JztcbiAgICAgICAgc2NvcGUub3B0aW9ucy5zZXBhcmF0b3IgPSBzY29wZS5vcHRpb25zLnNlcGFyYXRvciB8fCAnfCc7XG4gICAgICAgIHNjb3BlLm9wdGlvbnMuY29udGFpbmVyID0gc2NvcGUub3B0aW9ucy5jb250YWluZXIgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNjb3BlLm9wdGlvbnMuY29udGFpbmVyKSA6IGZhbHNlO1xuICAgICAgICBzY29wZS5vcHRpb25zLmVycm9yQ2xhc3MgPSBzY29wZS5vcHRpb25zLmVycm9yQ2xhc3MgfHwgJ2ItZXJyb3InO1xuICAgICAgICBzY29wZS5vcHRpb25zLmJyZWFrcG9pbnRzID0gc2NvcGUub3B0aW9ucy5icmVha3BvaW50cyB8fCBmYWxzZTtcbiAgICAgICAgc2NvcGUub3B0aW9ucy5sb2FkSW52aXNpYmxlID0gc2NvcGUub3B0aW9ucy5sb2FkSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgICBzY29wZS5vcHRpb25zLnN1Y2Nlc3NDbGFzcyA9IHNjb3BlLm9wdGlvbnMuc3VjY2Vzc0NsYXNzIHx8ICdiLWxvYWRlZCc7XG4gICAgICAgIHNjb3BlLm9wdGlvbnMudmFsaWRhdGVEZWxheSA9IHNjb3BlLm9wdGlvbnMudmFsaWRhdGVEZWxheSB8fCAyNTtcbiAgICAgICAgc2NvcGUub3B0aW9ucy5zYXZlVmlld3BvcnRPZmZzZXREZWxheSA9IHNjb3BlLm9wdGlvbnMuc2F2ZVZpZXdwb3J0T2Zmc2V0RGVsYXkgfHwgNTA7XG4gICAgICAgIHNjb3BlLm9wdGlvbnMuc3JjID0gc291cmNlID0gc2NvcGUub3B0aW9ucy5zcmMgfHwgJ2RhdGEtc3JjJztcbiAgICAgICAgaXNSZXRpbmEgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDE7XG4gICAgICAgIHZpZXdwb3J0ID0ge307XG4gICAgICAgIHZpZXdwb3J0LnRvcCA9IDAgLSBzY29wZS5vcHRpb25zLm9mZnNldDtcbiAgICAgICAgdmlld3BvcnQubGVmdCA9IDAgLSBzY29wZS5vcHRpb25zLm9mZnNldDtcblxuXG4gICAgICAgIC8qIHB1YmxpYyBmdW5jdGlvbnNcbiAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgc2NvcGUucmV2YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaW5pdGlhbGl6ZSh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2NvcGUubG9hZCA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBmb3JjZSkge1xuICAgICAgICAgICAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvYWRFbGVtZW50KGVsZW1lbnRzLCBmb3JjZSwgb3B0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWFjaChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBsb2FkRWxlbWVudChlbGVtZW50LCBmb3JjZSwgb3B0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2NvcGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHV0aWwgPSBzZWxmLl91dGlsO1xuICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5jb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBlYWNoKHNlbGYub3B0aW9ucy5jb250YWluZXIsIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB1bmJpbmRFdmVudChvYmplY3QsICdzY3JvbGwnLCB1dGlsLnZhbGlkYXRlVCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bmJpbmRFdmVudCh3aW5kb3csICdzY3JvbGwnLCB1dGlsLnZhbGlkYXRlVCk7XG4gICAgICAgICAgICB1bmJpbmRFdmVudCh3aW5kb3csICdyZXNpemUnLCB1dGlsLnZhbGlkYXRlVCk7XG4gICAgICAgICAgICB1bmJpbmRFdmVudCh3aW5kb3csICdyZXNpemUnLCB1dGlsLnNhdmVWaWV3cG9ydE9mZnNldFQpO1xuICAgICAgICAgICAgdXRpbC5jb3VudCA9IDA7XG4gICAgICAgICAgICB1dGlsLmVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB1dGlsLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy90aHJvdHRsZSwgZW5zdXJlcyB0aGF0IHdlIGRvbid0IGNhbGwgdGhlIGZ1bmN0aW9ucyB0b28gb2Z0ZW5cbiAgICAgICAgdXRpbC52YWxpZGF0ZVQgPSB0aHJvdHRsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlKHNjb3BlKTtcbiAgICAgICAgfSwgc2NvcGUub3B0aW9ucy52YWxpZGF0ZURlbGF5LCBzY29wZSk7XG4gICAgICAgIHV0aWwuc2F2ZVZpZXdwb3J0T2Zmc2V0VCA9IHRocm90dGxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2F2ZVZpZXdwb3J0T2Zmc2V0KHNjb3BlLm9wdGlvbnMub2Zmc2V0KTtcbiAgICAgICAgfSwgc2NvcGUub3B0aW9ucy5zYXZlVmlld3BvcnRPZmZzZXREZWxheSwgc2NvcGUpO1xuICAgICAgICBzYXZlVmlld3BvcnRPZmZzZXQoc2NvcGUub3B0aW9ucy5vZmZzZXQpO1xuXG4gICAgICAgIC8vaGFuZGxlIG11bHRpLXNlcnZlZCBpbWFnZSBzcmNcbiAgICAgICAgZWFjaChzY29wZS5vcHRpb25zLmJyZWFrcG9pbnRzLCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3Qud2lkdGggPj0gd2luZG93LnNjcmVlbi53aWR0aCkge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IG9iamVjdC5zcmM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzdGFydCBsYXp5IGxvYWRcbiAgICAgICAgaW5pdGlhbGl6ZShzY29wZSk7XG4gICAgfTtcblxuXG4gICAgLyogUHJpdmF0ZSBoZWxwZXIgZnVuY3Rpb25zXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICBmdW5jdGlvbiBpbml0aWFsaXplKHNlbGYpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB1dGlsID0gc2VsZi5fdXRpbDtcbiAgICAgICAgICAgIC8vIEZpcnN0IHdlIGNyZWF0ZSBhbiBhcnJheSBvZiBlbGVtZW50cyB0byBsYXp5IGxvYWRcbiAgICAgICAgICAgIHV0aWwuZWxlbWVudHMgPSB0b0FycmF5KHNlbGYub3B0aW9ucy5zZWxlY3Rvcik7XG4gICAgICAgICAgICB1dGlsLmNvdW50ID0gdXRpbC5lbGVtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAvLyBUaGVuIHdlIGJpbmQgcmVzaXplIGFuZCBzY3JvbGwgZXZlbnRzIGlmIG5vdCBhbHJlYWR5IGJpbmRlZFxuICAgICAgICAgICAgaWYgKHV0aWwuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdXRpbC5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBlYWNoKHNlbGYub3B0aW9ucy5jb250YWluZXIsIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmluZEV2ZW50KG9iamVjdCwgJ3Njcm9sbCcsIHV0aWwudmFsaWRhdGVUKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJpbmRFdmVudCh3aW5kb3csICdyZXNpemUnLCB1dGlsLnNhdmVWaWV3cG9ydE9mZnNldFQpO1xuICAgICAgICAgICAgICAgIGJpbmRFdmVudCh3aW5kb3csICdyZXNpemUnLCB1dGlsLnZhbGlkYXRlVCk7XG4gICAgICAgICAgICAgICAgYmluZEV2ZW50KHdpbmRvdywgJ3Njcm9sbCcsIHV0aWwudmFsaWRhdGVUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFuZCBmaW5hbGx5LCB3ZSBzdGFydCB0byBsYXp5IGxvYWQuXG4gICAgICAgICAgICB2YWxpZGF0ZShzZWxmKTtcbiAgICAgICAgfSwgMSk7IC8vIFwiZG9tIHJlYWR5XCIgZml4XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUoc2VsZikge1xuICAgICAgICB2YXIgdXRpbCA9IHNlbGYuX3V0aWw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXRpbC5jb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHV0aWwuZWxlbWVudHNbaV07XG4gICAgICAgICAgICBpZiAoZWxlbWVudEluVmlldyhlbGVtZW50KSB8fCBoYXNDbGFzcyhlbGVtZW50LCBzZWxmLm9wdGlvbnMuc3VjY2Vzc0NsYXNzKSkge1xuICAgICAgICAgICAgICAgIHNlbGYubG9hZChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB1dGlsLmVsZW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB1dGlsLmNvdW50LS07XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1dGlsLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBzZWxmLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVsZW1lbnRJblZpZXcoZWxlKSB7XG4gICAgICAgIHZhciByZWN0ID0gZWxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLy8gSW50ZXJzZWN0aW9uXG4gICAgICAgICAgICByZWN0LnJpZ2h0ID49IHZpZXdwb3J0LmxlZnQgJiYgcmVjdC5ib3R0b20gPj0gdmlld3BvcnQudG9wICYmIHJlY3QubGVmdCA8PSB2aWV3cG9ydC5yaWdodCAmJiByZWN0LnRvcCA8PSB2aWV3cG9ydC5ib3R0b21cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkRWxlbWVudChlbGUsIGZvcmNlLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIGlmIGVsZW1lbnQgaXMgdmlzaWJsZSwgbm90IGxvYWRlZCBvciBmb3JjZWRcbiAgICAgICAgaWYgKCFoYXNDbGFzcyhlbGUsIG9wdGlvbnMuc3VjY2Vzc0NsYXNzKSAmJiAoZm9yY2UgfHwgb3B0aW9ucy5sb2FkSW52aXNpYmxlIHx8IChlbGUub2Zmc2V0V2lkdGggPiAwICYmIGVsZS5vZmZzZXRIZWlnaHQgPiAwKSkpIHtcbiAgICAgICAgICAgIHZhciBkYXRhU3JjID0gZWxlLmdldEF0dHJpYnV0ZShzb3VyY2UpIHx8IGVsZS5nZXRBdHRyaWJ1dGUob3B0aW9ucy5zcmMpOyAvLyBmYWxsYmFjayB0byBkZWZhdWx0ICdkYXRhLXNyYydcbiAgICAgICAgICAgIGlmIChkYXRhU3JjKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFTcmNTcGxpdHRlZCA9IGRhdGFTcmMuc3BsaXQob3B0aW9ucy5zZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgIHZhciBzcmMgPSBkYXRhU3JjU3BsaXR0ZWRbaXNSZXRpbmEgJiYgZGF0YVNyY1NwbGl0dGVkLmxlbmd0aCA+IDEgPyAxIDogMF07XG4gICAgICAgICAgICAgICAgdmFyIGlzSW1hZ2UgPSBlbGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ltZyc7XG4gICAgICAgICAgICAgICAgLy8gSW1hZ2Ugb3IgYmFja2dyb3VuZCBpbWFnZVxuICAgICAgICAgICAgICAgIGlmIChpc0ltYWdlIHx8IGVsZS5zcmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lcnJvcikgb3B0aW9ucy5lcnJvcihlbGUsIFwiaW52YWxpZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKGVsZSwgb3B0aW9ucy5lcnJvckNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXMgZWxlbWVudCBhbiBpbWFnZSBvciBzaG91bGQgd2UgYWRkIHRoZSBzcmMgYXMgYSBiYWNrZ3JvdW5kIGltYWdlP1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNJbWFnZSA/IGVsZS5zcmMgPSBzcmMgOiBlbGUuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJ3VybChcIicgKyBzcmMgKyAnXCIpJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Mb2FkZWQoZWxlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaW1nLnNyYyA9IHNyYzsgLy9wcmVsb2FkXG4gICAgICAgICAgICAgICAgICAgIC8vIEFuIGl0ZW0gd2l0aCBzcmMgbGlrZSBpZnJhbWUsIHVuaXR5LCB2aWRlbyBldGNcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGUuc3JjID0gc3JjO1xuICAgICAgICAgICAgICAgICAgICBpdGVtTG9hZGVkKGVsZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lcnJvcikgb3B0aW9ucy5lcnJvcihlbGUsIFwibWlzc2luZ1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0NsYXNzKGVsZSwgb3B0aW9ucy5lcnJvckNsYXNzKSkgYWRkQ2xhc3MoZWxlLCBvcHRpb25zLmVycm9yQ2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXRlbUxvYWRlZChlbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgYWRkQ2xhc3MoZWxlLCBvcHRpb25zLnN1Y2Nlc3NDbGFzcyk7XG4gICAgICAgIGlmIChvcHRpb25zLnN1Y2Nlc3MpIG9wdGlvbnMuc3VjY2VzcyhlbGUpO1xuICAgICAgICAvLyBjbGVhbnVwIG1hcmt1cCwgcmVtb3ZlIGRhdGEgc291cmNlIGF0dHJpYnV0ZXNcbiAgICAgICAgZWFjaChvcHRpb25zLmJyZWFrcG9pbnRzLCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICAgIGVsZS5yZW1vdmVBdHRyaWJ1dGUob2JqZWN0LnNyYyk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbGUucmVtb3ZlQXR0cmlidXRlKG9wdGlvbnMuc3JjKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNDbGFzcyhlbGUsIGNsYXNzTmFtZSkge1xuICAgICAgICByZXR1cm4gKCcgJyArIGVsZS5jbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgY2xhc3NOYW1lICsgJyAnKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlLCBjbGFzc05hbWUpIHtcbiAgICAgICAgZWxlLmNsYXNzTmFtZSA9IGVsZS5jbGFzc05hbWUgKyAnICcgKyBjbGFzc05hbWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9BcnJheShzZWxlY3Rvcikge1xuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIG5vZGVsaXN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgIGZvciAodmFyIGkgPSBub2RlbGlzdC5sZW5ndGg7IGktLTsgYXJyYXkudW5zaGlmdChub2RlbGlzdFtpXSkpIHt9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzYXZlVmlld3BvcnRPZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIHZpZXdwb3J0LmJvdHRvbSA9ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkgKyBvZmZzZXQ7XG4gICAgICAgIHZpZXdwb3J0LnJpZ2h0ID0gKHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCkgKyBvZmZzZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmluZEV2ZW50KGVsZSwgdHlwZSwgZm4pIHtcbiAgICAgICAgaWYgKGVsZS5hdHRhY2hFdmVudCkge1xuICAgICAgICAgICAgZWxlLmF0dGFjaEV2ZW50ICYmIGVsZS5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgZm4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuYmluZEV2ZW50KGVsZSwgdHlwZSwgZm4pIHtcbiAgICAgICAgaWYgKGVsZS5kZXRhY2hFdmVudCkge1xuICAgICAgICAgICAgZWxlLmRldGFjaEV2ZW50ICYmIGVsZS5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgZm4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVhY2gob2JqZWN0LCBmbikge1xuICAgICAgICBpZiAob2JqZWN0ICYmIGZuKSB7XG4gICAgICAgICAgICB2YXIgbCA9IG9iamVjdC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGwgJiYgZm4ob2JqZWN0W2ldLCBpKSAhPT0gZmFsc2U7IGkrKykge31cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZuLCBtaW5EZWxheSwgc2NvcGUpIHtcbiAgICAgICAgdmFyIGxhc3RDYWxsID0gMDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG5vdyA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgaWYgKG5vdyAtIGxhc3RDYWxsIDwgbWluRGVsYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0Q2FsbCA9IG5vdztcbiAgICAgICAgICAgIGZuLmFwcGx5KHNjb3BlLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cbn0pOyJdLCJmaWxlIjoiYmxhenkubWluLmpzIn0=
