/*!
  hey, [be]Lazy.js - v1.5.2 - 2015.12.01
  A lazy loading and multi-serving image script
  (c) Bjoern Klinggaard - @bklinggaard - http://dinbror.dk/blazy
*/

(function(root, blazy) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register bLazy as an anonymous module
        define(blazy);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = blazy();
    } else {
        // Browser globals. Register bLazy on window
        root.Blazy = blazy();
    }
})(this, function() {
    'use strict';

    //private vars
    var source, viewport, isRetina;

    // constructor
    return function Blazy(options) {
        //IE7- fallback for missing querySelectorAll support
        if (!document.querySelectorAll) {
            var s = document.createStyleSheet();
            document.querySelectorAll = function(r, c, i, j, a) {
                a = document.all, c = [], r = r.replace(/\[for\b/gi, '[htmlFor').split(',');
                for (i = r.length; i--;) {
                    s.addRule(r[i], 'k:v');
                    for (j = a.length; j--;) a[j].currentStyle.k && c.push(a[j]);
                    s.removeRule(0);
                }
                return c;
            };
        }

        //options and helper vars
        var scope = this;
        var util = scope._util = {};
        util.elements = [];
        util.destroyed = true;
        scope.options = options || {};
        scope.options.error = scope.options.error || false;
        scope.options.offset = scope.options.offset || 100;
        scope.options.success = scope.options.success || false;
        scope.options.selector = scope.options.selector || '.b-lazy';
        scope.options.separator = scope.options.separator || '|';
        scope.options.container = scope.options.container ? document.querySelectorAll(scope.options.container) : false;
        scope.options.errorClass = scope.options.errorClass || 'b-error';
        scope.options.breakpoints = scope.options.breakpoints || false;
        scope.options.loadInvisible = scope.options.loadInvisible || false;
        scope.options.successClass = scope.options.successClass || 'b-loaded';
		scope.options.validateDelay = scope.options.validateDelay || 25;
		scope.options.saveViewportOffsetDelay = scope.options.saveViewportOffsetDelay || 50;
        scope.options.src = source = scope.options.src || 'data-src';
        isRetina = window.devicePixelRatio > 1;
        viewport = {};
        viewport.top = 0 - scope.options.offset;
        viewport.left = 0 - scope.options.offset;


        /* public functions
         ************************************/
        scope.revalidate = function() {
            initialize(this);
        };
        scope.load = function(elements, force) {
            var opt = this.options;
            if (elements.length === undefined) {
                loadElement(elements, force, opt);
            } else {
                each(elements, function(element) {
                    loadElement(element, force, opt);
                });
            }
        };
        scope.destroy = function() {
            var self = this;
            var util = self._util;
            if (self.options.container) {
                each(self.options.container, function(object) {
                    unbindEvent(object, 'scroll', util.validateT);
                });
            }
            unbindEvent(window, 'scroll', util.validateT);
            unbindEvent(window, 'resize', util.validateT);
            unbindEvent(window, 'resize', util.saveViewportOffsetT);
            util.count = 0;
            util.elements.length = 0;
            util.destroyed = true;
        };

        //throttle, ensures that we don't call the functions too often
        util.validateT = throttle(function() {
            validate(scope);
        }, scope.options.validateDelay, scope);
        util.saveViewportOffsetT = throttle(function() {
            saveViewportOffset(scope.options.offset);
        }, scope.options.saveViewportOffsetDelay, scope);
        saveViewportOffset(scope.options.offset);

        //handle multi-served image src
        each(scope.options.breakpoints, function(object) {
            if (object.width >= window.screen.width) {
                source = object.src;
                return false;
            }
        });

        // start lazy load
        initialize(scope);
    };


    /* Private helper functions
     ************************************/
    function initialize(self) {
        var util = self._util;
        // First we create an array of elements to lazy load
        util.elements = toArray(self.options.selector);
        util.count = util.elements.length;
        // Then we bind resize and scroll events if not already binded
        if (util.destroyed) {
            util.destroyed = false;
            if (self.options.container) {
                each(self.options.container, function(object) {
                    bindEvent(object, 'scroll', util.validateT);
                });
            }
            bindEvent(window, 'resize', util.saveViewportOffsetT);
            bindEvent(window, 'resize', util.validateT);
            bindEvent(window, 'scroll', util.validateT);
        }
        // And finally, we start to lazy load. Should bLazy ensure domready?
        validate(self);
    }

    function validate(self) {
        var util = self._util;
        for (var i = 0; i < util.count; i++) {
            var element = util.elements[i];
            if (elementInView(element) || hasClass(element, self.options.successClass)) {
                self.load(element);
                util.elements.splice(i, 1);
                util.count--;
                i--;
            }
        }
        if (util.count === 0) {
            self.destroy();
        }
    }

    function elementInView(ele) {
        var rect = ele.getBoundingClientRect();
        return (
            // Intersection
            rect.right >= viewport.left && rect.bottom >= viewport.top && rect.left <= viewport.right && rect.top <= viewport.bottom
        );
    }

    function loadElement(ele, force, options) {
        // if element is visible, not loaded or forced
        if (!hasClass(ele, options.successClass) && (force || options.loadInvisible || (ele.offsetWidth > 0 && ele.offsetHeight > 0))) {
            var dataSrc = ele.getAttribute(source) || ele.getAttribute(options.src); // fallback to default 'data-src'
            if (dataSrc) {
                var dataSrcSplitted = dataSrc.split(options.separator);
                var src = dataSrcSplitted[isRetina && dataSrcSplitted.length > 1 ? 1 : 0];
                var isImage = ele.nodeName.toLowerCase() === 'img';
                // cleanup markup, remove data source attributes
                each(options.breakpoints, function(object) {
                    ele.removeAttribute(object.src);
                });
                ele.removeAttribute(options.src);
                if (isImage || ele.src === undefined) {
                    var img = new Image();
                    img.onerror = function() {
                        if (options.error) options.error(ele, "invalid");
                        addClass(ele, options.errorClass);
                    };
                    img.onload = function() {
                        // Is element an image or should we add the src as a background image?
                        isImage ? ele.src = src : ele.style.backgroundImage = 'url("' + src + '")';
                        addClass(ele, options.successClass);
                        if (options.success) options.success(ele);
                    };
					img.src = src; //preload
                } else {
					ele.src = src;
					addClass(ele, options.successClass);
				}
            } else {
                if (options.error) options.error(ele, "missing");
                if (!hasClass(ele, options.errorClass)) addClass(ele, options.errorClass);
            }
        }
    }

    function hasClass(ele, className) {
        return (' ' + ele.className + ' ').indexOf(' ' + className + ' ') !== -1;
    }

	function addClass(ele, className){
		ele.className = ele.className + ' ' + className;
	}

    function toArray(selector) {
		var array = [];
 		var nodelist = document.querySelectorAll(selector);
 		for(var i = nodelist.length; i--; array.unshift(nodelist[i])){}
		return array;
    }

    function saveViewportOffset(offset) {
        viewport.bottom = (window.innerHeight || document.documentElement.clientHeight) + offset;
        viewport.right = (window.innerWidth || document.documentElement.clientWidth) + offset;
    }

    function bindEvent(ele, type, fn) {
        if (ele.attachEvent) {
            ele.attachEvent && ele.attachEvent('on' + type, fn);
        } else {
            ele.addEventListener(type, fn, false);
        }
    }

    function unbindEvent(ele, type, fn) {
        if (ele.detachEvent) {
            ele.detachEvent && ele.detachEvent('on' + type, fn);
        } else {
            ele.removeEventListener(type, fn, false);
        }
    }

    function each(object, fn) {
        if (object && fn) {
            var l = object.length;
            for (var i = 0; i < l && fn(object[i], i) !== false; i++) {}
        }
    }

    function throttle(fn, minDelay, scope) {
        var lastCall = 0;
        return function() {
            var now = +new Date();
            if (now - lastCall < minDelay) {
                return;
            }
            lastCall = now;
            fn.apply(scope, arguments);
        };
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJibGF6eS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAgaGV5LCBbYmVdTGF6eS5qcyAtIHYxLjUuMiAtIDIwMTUuMTIuMDFcbiAgQSBsYXp5IGxvYWRpbmcgYW5kIG11bHRpLXNlcnZpbmcgaW1hZ2Ugc2NyaXB0XG4gIChjKSBCam9lcm4gS2xpbmdnYWFyZCAtIEBia2xpbmdnYWFyZCAtIGh0dHA6Ly9kaW5icm9yLmRrL2JsYXp5XG4qL1xuXG4oZnVuY3Rpb24ocm9vdCwgYmxhenkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYkxhenkgYXMgYW4gYW5vbnltb3VzIG1vZHVsZVxuICAgICAgICBkZWZpbmUoYmxhenkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcbiAgICAgICAgLy8gbGlrZSBOb2RlLlxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGJsYXp5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzLiBSZWdpc3RlciBiTGF6eSBvbiB3aW5kb3dcbiAgICAgICAgcm9vdC5CbGF6eSA9IGJsYXp5KCk7XG4gICAgfVxufSkodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy9wcml2YXRlIHZhcnNcbiAgICB2YXIgc291cmNlLCB2aWV3cG9ydCwgaXNSZXRpbmE7XG5cbiAgICAvLyBjb25zdHJ1Y3RvclxuICAgIHJldHVybiBmdW5jdGlvbiBCbGF6eShvcHRpb25zKSB7XG4gICAgICAgIC8vSUU3LSBmYWxsYmFjayBmb3IgbWlzc2luZyBxdWVyeVNlbGVjdG9yQWxsIHN1cHBvcnRcbiAgICAgICAgaWYgKCFkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKSB7XG4gICAgICAgICAgICB2YXIgcyA9IGRvY3VtZW50LmNyZWF0ZVN0eWxlU2hlZXQoKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgPSBmdW5jdGlvbihyLCBjLCBpLCBqLCBhKSB7XG4gICAgICAgICAgICAgICAgYSA9IGRvY3VtZW50LmFsbCwgYyA9IFtdLCByID0gci5yZXBsYWNlKC9cXFtmb3JcXGIvZ2ksICdbaHRtbEZvcicpLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gci5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgICAgICAgICAgcy5hZGRSdWxlKHJbaV0sICdrOnYnKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gYS5sZW5ndGg7IGotLTspIGFbal0uY3VycmVudFN0eWxlLmsgJiYgYy5wdXNoKGFbal0pO1xuICAgICAgICAgICAgICAgICAgICBzLnJlbW92ZVJ1bGUoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vb3B0aW9ucyBhbmQgaGVscGVyIHZhcnNcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgICAgdmFyIHV0aWwgPSBzY29wZS5fdXRpbCA9IHt9O1xuICAgICAgICB1dGlsLmVsZW1lbnRzID0gW107XG4gICAgICAgIHV0aWwuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgc2NvcGUub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHNjb3BlLm9wdGlvbnMuZXJyb3IgPSBzY29wZS5vcHRpb25zLmVycm9yIHx8IGZhbHNlO1xuICAgICAgICBzY29wZS5vcHRpb25zLm9mZnNldCA9IHNjb3BlLm9wdGlvbnMub2Zmc2V0IHx8IDEwMDtcbiAgICAgICAgc2NvcGUub3B0aW9ucy5zdWNjZXNzID0gc2NvcGUub3B0aW9ucy5zdWNjZXNzIHx8IGZhbHNlO1xuICAgICAgICBzY29wZS5vcHRpb25zLnNlbGVjdG9yID0gc2NvcGUub3B0aW9ucy5zZWxlY3RvciB8fCAnLmItbGF6eSc7XG4gICAgICAgIHNjb3BlLm9wdGlvbnMuc2VwYXJhdG9yID0gc2NvcGUub3B0aW9ucy5zZXBhcmF0b3IgfHwgJ3wnO1xuICAgICAgICBzY29wZS5vcHRpb25zLmNvbnRhaW5lciA9IHNjb3BlLm9wdGlvbnMuY29udGFpbmVyID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzY29wZS5vcHRpb25zLmNvbnRhaW5lcikgOiBmYWxzZTtcbiAgICAgICAgc2NvcGUub3B0aW9ucy5lcnJvckNsYXNzID0gc2NvcGUub3B0aW9ucy5lcnJvckNsYXNzIHx8ICdiLWVycm9yJztcbiAgICAgICAgc2NvcGUub3B0aW9ucy5icmVha3BvaW50cyA9IHNjb3BlLm9wdGlvbnMuYnJlYWtwb2ludHMgfHwgZmFsc2U7XG4gICAgICAgIHNjb3BlLm9wdGlvbnMubG9hZEludmlzaWJsZSA9IHNjb3BlLm9wdGlvbnMubG9hZEludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgICAgc2NvcGUub3B0aW9ucy5zdWNjZXNzQ2xhc3MgPSBzY29wZS5vcHRpb25zLnN1Y2Nlc3NDbGFzcyB8fCAnYi1sb2FkZWQnO1xuXHRcdHNjb3BlLm9wdGlvbnMudmFsaWRhdGVEZWxheSA9IHNjb3BlLm9wdGlvbnMudmFsaWRhdGVEZWxheSB8fCAyNTtcblx0XHRzY29wZS5vcHRpb25zLnNhdmVWaWV3cG9ydE9mZnNldERlbGF5ID0gc2NvcGUub3B0aW9ucy5zYXZlVmlld3BvcnRPZmZzZXREZWxheSB8fCA1MDtcbiAgICAgICAgc2NvcGUub3B0aW9ucy5zcmMgPSBzb3VyY2UgPSBzY29wZS5vcHRpb25zLnNyYyB8fCAnZGF0YS1zcmMnO1xuICAgICAgICBpc1JldGluYSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID4gMTtcbiAgICAgICAgdmlld3BvcnQgPSB7fTtcbiAgICAgICAgdmlld3BvcnQudG9wID0gMCAtIHNjb3BlLm9wdGlvbnMub2Zmc2V0O1xuICAgICAgICB2aWV3cG9ydC5sZWZ0ID0gMCAtIHNjb3BlLm9wdGlvbnMub2Zmc2V0O1xuXG5cbiAgICAgICAgLyogcHVibGljIGZ1bmN0aW9uc1xuICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICBzY29wZS5yZXZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpbml0aWFsaXplKHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBzY29wZS5sb2FkID0gZnVuY3Rpb24oZWxlbWVudHMsIGZvcmNlKSB7XG4gICAgICAgICAgICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9hZEVsZW1lbnQoZWxlbWVudHMsIGZvcmNlLCBvcHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRFbGVtZW50KGVsZW1lbnQsIGZvcmNlLCBvcHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzY29wZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgdXRpbCA9IHNlbGYuX3V0aWw7XG4gICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIGVhY2goc2VsZi5vcHRpb25zLmNvbnRhaW5lciwgZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHVuYmluZEV2ZW50KG9iamVjdCwgJ3Njcm9sbCcsIHV0aWwudmFsaWRhdGVUKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVuYmluZEV2ZW50KHdpbmRvdywgJ3Njcm9sbCcsIHV0aWwudmFsaWRhdGVUKTtcbiAgICAgICAgICAgIHVuYmluZEV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScsIHV0aWwudmFsaWRhdGVUKTtcbiAgICAgICAgICAgIHVuYmluZEV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScsIHV0aWwuc2F2ZVZpZXdwb3J0T2Zmc2V0VCk7XG4gICAgICAgICAgICB1dGlsLmNvdW50ID0gMDtcbiAgICAgICAgICAgIHV0aWwuZWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHV0aWwuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL3Rocm90dGxlLCBlbnN1cmVzIHRoYXQgd2UgZG9uJ3QgY2FsbCB0aGUgZnVuY3Rpb25zIHRvbyBvZnRlblxuICAgICAgICB1dGlsLnZhbGlkYXRlVCA9IHRocm90dGxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFsaWRhdGUoc2NvcGUpO1xuICAgICAgICB9LCBzY29wZS5vcHRpb25zLnZhbGlkYXRlRGVsYXksIHNjb3BlKTtcbiAgICAgICAgdXRpbC5zYXZlVmlld3BvcnRPZmZzZXRUID0gdGhyb3R0bGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzYXZlVmlld3BvcnRPZmZzZXQoc2NvcGUub3B0aW9ucy5vZmZzZXQpO1xuICAgICAgICB9LCBzY29wZS5vcHRpb25zLnNhdmVWaWV3cG9ydE9mZnNldERlbGF5LCBzY29wZSk7XG4gICAgICAgIHNhdmVWaWV3cG9ydE9mZnNldChzY29wZS5vcHRpb25zLm9mZnNldCk7XG5cbiAgICAgICAgLy9oYW5kbGUgbXVsdGktc2VydmVkIGltYWdlIHNyY1xuICAgICAgICBlYWNoKHNjb3BlLm9wdGlvbnMuYnJlYWtwb2ludHMsIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdC53aWR0aCA+PSB3aW5kb3cuc2NyZWVuLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgc291cmNlID0gb2JqZWN0LnNyYztcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHN0YXJ0IGxhenkgbG9hZFxuICAgICAgICBpbml0aWFsaXplKHNjb3BlKTtcbiAgICB9O1xuXG5cbiAgICAvKiBQcml2YXRlIGhlbHBlciBmdW5jdGlvbnNcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWxpemUoc2VsZikge1xuICAgICAgICB2YXIgdXRpbCA9IHNlbGYuX3V0aWw7XG4gICAgICAgIC8vIEZpcnN0IHdlIGNyZWF0ZSBhbiBhcnJheSBvZiBlbGVtZW50cyB0byBsYXp5IGxvYWRcbiAgICAgICAgdXRpbC5lbGVtZW50cyA9IHRvQXJyYXkoc2VsZi5vcHRpb25zLnNlbGVjdG9yKTtcbiAgICAgICAgdXRpbC5jb3VudCA9IHV0aWwuZWxlbWVudHMubGVuZ3RoO1xuICAgICAgICAvLyBUaGVuIHdlIGJpbmQgcmVzaXplIGFuZCBzY3JvbGwgZXZlbnRzIGlmIG5vdCBhbHJlYWR5IGJpbmRlZFxuICAgICAgICBpZiAodXRpbC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHV0aWwuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIGVhY2goc2VsZi5vcHRpb25zLmNvbnRhaW5lciwgZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRFdmVudChvYmplY3QsICdzY3JvbGwnLCB1dGlsLnZhbGlkYXRlVCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaW5kRXZlbnQod2luZG93LCAncmVzaXplJywgdXRpbC5zYXZlVmlld3BvcnRPZmZzZXRUKTtcbiAgICAgICAgICAgIGJpbmRFdmVudCh3aW5kb3csICdyZXNpemUnLCB1dGlsLnZhbGlkYXRlVCk7XG4gICAgICAgICAgICBiaW5kRXZlbnQod2luZG93LCAnc2Nyb2xsJywgdXRpbC52YWxpZGF0ZVQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFuZCBmaW5hbGx5LCB3ZSBzdGFydCB0byBsYXp5IGxvYWQuIFNob3VsZCBiTGF6eSBlbnN1cmUgZG9tcmVhZHk/XG4gICAgICAgIHZhbGlkYXRlKHNlbGYpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHNlbGYpIHtcbiAgICAgICAgdmFyIHV0aWwgPSBzZWxmLl91dGlsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHV0aWwuY291bnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB1dGlsLmVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRJblZpZXcoZWxlbWVudCkgfHwgaGFzQ2xhc3MoZWxlbWVudCwgc2VsZi5vcHRpb25zLnN1Y2Nlc3NDbGFzcykpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmxvYWQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdXRpbC5lbGVtZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgdXRpbC5jb3VudC0tO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXRpbC5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgc2VsZi5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbGVtZW50SW5WaWV3KGVsZSkge1xuICAgICAgICB2YXIgcmVjdCA9IGVsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIC8vIEludGVyc2VjdGlvblxuICAgICAgICAgICAgcmVjdC5yaWdodCA+PSB2aWV3cG9ydC5sZWZ0ICYmIHJlY3QuYm90dG9tID49IHZpZXdwb3J0LnRvcCAmJiByZWN0LmxlZnQgPD0gdmlld3BvcnQucmlnaHQgJiYgcmVjdC50b3AgPD0gdmlld3BvcnQuYm90dG9tXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZEVsZW1lbnQoZWxlLCBmb3JjZSwgb3B0aW9ucykge1xuICAgICAgICAvLyBpZiBlbGVtZW50IGlzIHZpc2libGUsIG5vdCBsb2FkZWQgb3IgZm9yY2VkXG4gICAgICAgIGlmICghaGFzQ2xhc3MoZWxlLCBvcHRpb25zLnN1Y2Nlc3NDbGFzcykgJiYgKGZvcmNlIHx8IG9wdGlvbnMubG9hZEludmlzaWJsZSB8fCAoZWxlLm9mZnNldFdpZHRoID4gMCAmJiBlbGUub2Zmc2V0SGVpZ2h0ID4gMCkpKSB7XG4gICAgICAgICAgICB2YXIgZGF0YVNyYyA9IGVsZS5nZXRBdHRyaWJ1dGUoc291cmNlKSB8fCBlbGUuZ2V0QXR0cmlidXRlKG9wdGlvbnMuc3JjKTsgLy8gZmFsbGJhY2sgdG8gZGVmYXVsdCAnZGF0YS1zcmMnXG4gICAgICAgICAgICBpZiAoZGF0YVNyYykge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhU3JjU3BsaXR0ZWQgPSBkYXRhU3JjLnNwbGl0KG9wdGlvbnMuc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICB2YXIgc3JjID0gZGF0YVNyY1NwbGl0dGVkW2lzUmV0aW5hICYmIGRhdGFTcmNTcGxpdHRlZC5sZW5ndGggPiAxID8gMSA6IDBdO1xuICAgICAgICAgICAgICAgIHZhciBpc0ltYWdlID0gZWxlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbWcnO1xuICAgICAgICAgICAgICAgIC8vIGNsZWFudXAgbWFya3VwLCByZW1vdmUgZGF0YSBzb3VyY2UgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIGVhY2gob3B0aW9ucy5icmVha3BvaW50cywgZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZS5yZW1vdmVBdHRyaWJ1dGUob2JqZWN0LnNyYyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZWxlLnJlbW92ZUF0dHJpYnV0ZShvcHRpb25zLnNyYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzSW1hZ2UgfHwgZWxlLnNyYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVycm9yKSBvcHRpb25zLmVycm9yKGVsZSwgXCJpbnZhbGlkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoZWxlLCBvcHRpb25zLmVycm9yQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJcyBlbGVtZW50IGFuIGltYWdlIG9yIHNob3VsZCB3ZSBhZGQgdGhlIHNyYyBhcyBhIGJhY2tncm91bmQgaW1hZ2U/XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ltYWdlID8gZWxlLnNyYyA9IHNyYyA6IGVsZS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAndXJsKFwiJyArIHNyYyArICdcIiknO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoZWxlLCBvcHRpb25zLnN1Y2Nlc3NDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdWNjZXNzKSBvcHRpb25zLnN1Y2Nlc3MoZWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblx0XHRcdFx0XHRpbWcuc3JjID0gc3JjOyAvL3ByZWxvYWRcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZS5zcmMgPSBzcmM7XG5cdFx0XHRcdFx0YWRkQ2xhc3MoZWxlLCBvcHRpb25zLnN1Y2Nlc3NDbGFzcyk7XG5cdFx0XHRcdH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXJyb3IpIG9wdGlvbnMuZXJyb3IoZWxlLCBcIm1pc3NpbmdcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNDbGFzcyhlbGUsIG9wdGlvbnMuZXJyb3JDbGFzcykpIGFkZENsYXNzKGVsZSwgb3B0aW9ucy5lcnJvckNsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0NsYXNzKGVsZSwgY2xhc3NOYW1lKSB7XG4gICAgICAgIHJldHVybiAoJyAnICsgZWxlLmNsYXNzTmFtZSArICcgJykuaW5kZXhPZignICcgKyBjbGFzc05hbWUgKyAnICcpICE9PSAtMTtcbiAgICB9XG5cblx0ZnVuY3Rpb24gYWRkQ2xhc3MoZWxlLCBjbGFzc05hbWUpe1xuXHRcdGVsZS5jbGFzc05hbWUgPSBlbGUuY2xhc3NOYW1lICsgJyAnICsgY2xhc3NOYW1lO1xuXHR9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5KHNlbGVjdG9yKSB7XG5cdFx0dmFyIGFycmF5ID0gW107XG4gXHRcdHZhciBub2RlbGlzdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuIFx0XHRmb3IodmFyIGkgPSBub2RlbGlzdC5sZW5ndGg7IGktLTsgYXJyYXkudW5zaGlmdChub2RlbGlzdFtpXSkpe31cblx0XHRyZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2F2ZVZpZXdwb3J0T2Zmc2V0KG9mZnNldCkge1xuICAgICAgICB2aWV3cG9ydC5ib3R0b20gPSAod2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpICsgb2Zmc2V0O1xuICAgICAgICB2aWV3cG9ydC5yaWdodCA9ICh3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgpICsgb2Zmc2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpbmRFdmVudChlbGUsIHR5cGUsIGZuKSB7XG4gICAgICAgIGlmIChlbGUuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIGVsZS5hdHRhY2hFdmVudCAmJiBlbGUuYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGZuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmJpbmRFdmVudChlbGUsIHR5cGUsIGZuKSB7XG4gICAgICAgIGlmIChlbGUuZGV0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIGVsZS5kZXRhY2hFdmVudCAmJiBlbGUuZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGZuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlYWNoKG9iamVjdCwgZm4pIHtcbiAgICAgICAgaWYgKG9iamVjdCAmJiBmbikge1xuICAgICAgICAgICAgdmFyIGwgPSBvYmplY3QubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsICYmIGZuKG9iamVjdFtpXSwgaSkgIT09IGZhbHNlOyBpKyspIHt9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aHJvdHRsZShmbiwgbWluRGVsYXksIHNjb3BlKSB7XG4gICAgICAgIHZhciBsYXN0Q2FsbCA9IDA7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBub3cgPSArbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGlmIChub3cgLSBsYXN0Q2FsbCA8IG1pbkRlbGF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdENhbGwgPSBub3c7XG4gICAgICAgICAgICBmbi5hcHBseShzY29wZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9XG59KTsiXSwiZmlsZSI6ImJsYXp5Lm1pbi5qcyIsInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
